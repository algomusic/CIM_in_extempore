;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; LOADS
;;
;; command for precopmiling cimlib
;; first copy cimlib into "extempore/libs/contrib/cimlib.xtm"
;; then start extempore (without loading or running anything!)
;;
;; then eval this expr:
;;
;; (sys:precomp:compile-xtm-file "libs/contrib/cimlib.xtm" #t #t #t)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define with-dsp? (if (or (string=? "" (sys:cmdarg "audio"))
                          (string=? "0" (sys:cmdarg "audio")))
                      #f #t))

(define with-sustain? (if (or (string=? "" (sys:cmdarg "sustain"))
                              (string=? "0" (sys:cmdarg "sustain")))
                          #f #t))

(define with-midicc? (if (or (string=? "" (sys:cmdarg "midicc"))
                             (string=? "0" (sys:cmdarg "midicc")))
                         #f #t))

(define with-osc? (if (or (string=? "" (sys:cmdarg "osc"))
                          (string=? "0" (sys:cmdarg "osc")))
                      #f #t))

(define midi-out-port 
  (if (string=? "" (sys:cmdarg "midi-out"))
      0
      (string->number (sys:cmdarg "midi-out"))))

(define midi-in-port 
  (if (string=? "" (sys:cmdarg "midi-in"))
      0
      (string->number (sys:cmdarg "midi-in"))))

;; 
(println "MIDI out port is" midi-out-port "MIDI in port is" midi-in-port)

;; midi initialization first!
;; cimlib overloads certain midi input funcs
(sys:load "libs/external/midi_input.xtm")

(set_midi_in midi-in-port)

(define *midi-out* (pm_create_output_stream midi-out-port))

;;(sys:load "../CIM_in_extempore/cimlib.xtm")
(sys:load "/Users/andrew/Documents/code/CIM_in_extempore/cimlib.xtm")
(sys:load "libs/core/pc_ivl.xtm")
(if with-dsp? (sys:load "libs/external/instruments_ext.xtm"))

(println "Sustain playback is: " with-sustain?)  
(println "Local audio playback is: " with-dsp?)
(println "CC playback?: " with-midicc?)

;;;;;;;;;;;;;;;;;;;;;;
;;
;; osc stuff
;;
;;;;;;;;;;;;;;;;;;;;;;

(define *osc:on* with-osc?)

(if *osc:on* (io:osc:start-server 9000 "osc-receive-9000"))

;; define a sending address
(define addy1 (cons "169.254.52.46" 9000))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; utilities
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; utilities
(define panic
  (lambda (stream)
    (pm_send stream *midi-cc* 0 64 0)
  	(dotimes (c 16)
  		(dotimes (i 127)
        (pm_send stream 8 c i 0)))))


(define current-pcs
  (lambda ()
    (let ((pcs_cptr (current_pcs)))
      (map (lambda (i)
             (cptr:get-i64 pcs_cptr (* i 8)))
           (range 0 12)))))


;; where timea and timeb are limits for startime not endtime
;; where variance is a distance 'around' timea and timeb
(if with-dsp?
    (eval
     '(bind-func note_playback
       (lambda (time instrument startnote:CIMNote* endnote:CIMNote*)
         (println "playback -------")
         (println "from:" startnote)
         (println "to  :" endnote)
         (println)
         (if (or (null? startnote)
                 (null? endnote))
             void
             (let ((startidx (cim_note_index startnote))
                   (starttime (dtoi64 (* -1.0 CIMSRd (cim_note_onset startnote))))
                   (endidx (cim_note_index endnote))
                   (num (+ 1 (- endidx startidx)))
                   (note null)
                   (pitch 0)
                   (duration 0)
                   (i 0))
               (dotimes (i num)              
                 (set! note (retrieve_note (+ i startidx)))
                 (xtm_play_note (+ time
                                   (dtoi64 (* CIMSRd (cim_note_onset note)))
                                   starttime)
                                instrument                             
                                (midi2frq (i64tof (cim_note_pitch note)))
                                (/ (exp (/ (i64tof (cim_note_volume note)) 26.222)) 127.0)
                                (dtoi64 (* CIMSRd (cim_note_duration note)))
                                0 null))
               void))))
     (interaction-environment)))

;; (bind-poly note_playback note_playback_a)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; cim array helpers


(define cim_f64->list
  (lambda (a)
    (let ((size (cim_f64_size a))
          (lst (make-list-with-proc
                size
                (lambda (i)
                  (cim_f64_get a i)))))
      lst)))

(define list->cim_f64
  (lambda (l)
    (let ((size (length l))
          (a (cim_f64_create size)))
      (for-each (lambda (x i)
                  (cim_f64_set a i (* 1.0 x)))
                l)
      a)))

(define cim_i64->list
  (lambda (a)
    (let ((size (cim_i64_size a))
          (lst (make-list-with-proc
                size
                (lambda (i)
                  (cim_i64_get a i)))))
      lst)))

(define list->cim_i64
  (lambda (l)
    (let ((size (length l))
          (a (cim_i64_create size)))
      (for-each (lambda (x i)
                  (cim_i64_set a i (real->integer x)))
                l)
      a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; cim chunk helpers
;;

;; start with a default db
(define *DB* (list (cim_db_create 100)))

;; get the current db
(define db
  (lambda ()
    (car *DB*)))

;; push a new db onto the stack
(define push-db
  (lambda ()
    (set! *DB* (cons (cim_db_create 100) *DB*))
    (car *DB*)))

;; pop a db off the stack (probably don't need to do this)
(define pop-db
  (lambda ()
    (if (null? *DB*) *DB*
        (begin
          (set! *DB* (cdr *DB*))
          (if (null? *DB*) *DB*
              (car *DB*))))))

;; return an old DB (i.e. any db by index)
(define old-db
  (lambda (idx)
    (if (< idx (length *DB*))
        (list-ref *DB* idx)
        #f)))

;; updates the *current* db (i.e. (car *DB*))
(define update-db
  (lambda ()
    (cim_db_update_b (car *DB*))))


;; where returned list will be
(define chunk->scm
  (lambda (chunk)
    (let ((onsets (cim_f64->list (cim_chunk_onsets chunk)))
          (durations (cim_f64->list (cim_chunk_durations chunk)))
          (pitches (cim_i64->list (cim_chunk_pitches chunk)))
          (volumes (cim_i64->list (cim_chunk_volumes chunk))))
      (cim_f64_destroy onsets)
      (cim_f64_destroy durations)
      (cim_i64_destroy pitches)
      (cim_i64_destroy volumes)
      (list onsets pitches volumes durations))))

    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(if with-dsp?
    (eval 
     '(bind-func dsp:DSP 1000000
        (let ((t 0))
          (lambda (in time chan dat)
            (if (= t 0) (set! t time))
            (if (< chan 2)
                (+ (fmsynth in time chan dat)
                   0.0)
                0.0))))
     (interaction-environment)))

(if with-dsp?
    (begin
      (dsp:set! dsp)
      (fmsynth_fx.dfb .4)))

(define total-beat 0)

(define *bpm* 120)
(define *key* 0)
(define *density* 0)
(define *low* 127)
(define *high* 0)
(define *pcs* '())
(define *polyphony* 0)

;; pitch transformations
(define pitch-list '(60)) ;; start with dummy data

(define transform-pitches
  (lambda (lst chnkKey)
    (if (and (not (null? lst))
              (cl:find-if (lambda (x) (>= x 0)) lst))
      (let ((choice (random 5)))
        (print lst 'transform: choice '->)
        (case choice
          ((0 4) (set! pitch-list lst)) ;; no change
          ((1) (let ((p1 (car (cl:remove-if (lambda (x) (< x 0)) lst)))) ;; invert
                 (set! pitch-list (map (lambda (i) (if (>= i 0) (+ p1 (- p1 i)) i)) lst))))
          ((2) (set! pitch-list (map (lambda (i) (if (> i 48) (+ i (random -3 4)) i)) lst))) ;; jitter
          ((3) (let* ((p1 (car (cl:remove-if (lambda (x) (< x 0)) lst))) ;; transpose and jitter a bit
                     (trans (random (cond ((> p1 84)
                                            '(-12 0 -5))
                                          ((< p1 48)
                                            '(12 0 7 -5))
                                          (else '(0 2 -2 7 -5 12))))))
                  (set! pitch-list (map (lambda (i) (if (> i 40) (+ i trans (random -2 3)) i)) lst)))))
        ;; constrain to 88 note piano range
        (set! pitch-list (map (lambda (i) 
                              (if (> i 120) (- i 24) i)
                              (if (> i 108) (- i 12) i) 
                              (if (and (>= i 0) (< i 9)) (+ i 24) i)                
                              (if (and (>= i 0) (< i 21)) (+ i 12) i)) pitch-list))
        (println pitch-list)))))

    ;(set! pitch-list (map (lambda (i) (if (>= i 0) 60 i)) lst))))

;;(transform-pitches pitch-list)

(define get-pitches-from-chunk
  (lambda (chnk)
    (set! pitch-list
          (make-list-with-proc (cim_chunk_size chnk)
                               (lambda (i) (cim_chunk_note_pitch chnk i))))))

;; homophonic playnote
(define homo-play-midi-note
  (let ((notes (make-vector 127 0)))
    (lambda (time device pitch velocity duration channel)
      (if (and (> pitch 20) (< pitch 103)) ;; restrict to piano range
          (begin
            (if (> time (now))
                (if (and (> time (vector-ref notes pitch))
                         (> duration 500.0))
                    (let ((dur (if (> duration (* 2. *second*)) (* 2. *second*) duration)))
                      (record_midi_msg (real->integer time) *midi-note-on* 13 (real->integer pitch) (real->integer velocity))
                      (record_midi_msg (real->integer (+ time dur)) *midi-note-off* 13 (real->integer pitch) (real->integer velocity))
                      ;; (println 'dur: dur 'pitch: pitch)
                      (callback time 'pm_send device *midi-note-on* channel pitch velocity)
                      (callback (+ time dur) 'pm_send device *midi-note-off* channel pitch velocity))))
            (vector-set! notes pitch (+ time duration)))))))


;; playback
;; util - put in rtmidi-scm.xtm and push to git
(define-macro (hplay . args)
  (if (symbol? (car args))
      `(homo-play-midi-note (*metro* beat) ,(car args)
           (real->integer ,(cadr args))
           (real->integer ,(caddr args))
           (*metro* 'dur ,(car (cdddr args))) 0)
      `(homo-play-midi-note (*metro* (+ beat ,(car args))) ,(cadr args)
           (real->integer ,(caddr args))
           (real->integer ,(car (cdddr args)))
           (*metro* 'dur ,(cadr (cdddr args))) 0)))

(define play-midi-cc
  (lambda (time stream cc val channel)
    (record_midi_msg (real->integer time) *midi-cc* 13 (real->integer cc) (real->integer val))    
    (callback (real->integer time) 'pm_send stream *midi-cc* (real->integer channel) (real->integer cc) (real->integer val))))

(bind-func print_chunk_notes
  (lambda (index:i64 size:i64)
    (doloop (i size)
      (println (retrieve_note (+ i index))))))

;; bugs full gas stops playback (i.e p3 > 120)
;; latest phrase never available for playback.

(bind-func find_random_chunk_call
  (lambda (a b c d e f)
    (find_random_chunk a b c d e f)))

(bind-func total_chunks
  (lambda (gap startidx endix)
    (num_chunks gap startidx endix)))

(define play-chunk  
  (lambda (beat inst gap dcontrol)    
    ;; gap homophonic start end d1 d2
    ;; so defaults to accept everything in find_random (with 1.5s gap)
    ;; (find_random_chunk_a 1.5 0.0 0 0 0.0 10000.0)
    (let* (;(chunk (find_random_chunk_a gap (if (> *polyphony* 2) -10.0 0.0) 0 0 1.0 (* 2.0 dcontrol))) ;;1000.0))
           (last_idx (cim_note_index (last_note)))
           ;; (lllll (println 'last_note_index: last_idx))
           (num (total_chunks gap 0 0))
           ;; (lllllll (println 'num: num))
           ;gap homophonic startidx endidx upper lower (duration in beats)
           (chunk (find_random_chunk_call gap 0.0 0 0 0.0 (if (< (current_density) .01)
                                                              (* 4. dcontrol)
                                                              (* 2. dcontrol))))
           (chunkkey (cim_chunk_key chunk))
           (cmaj? (if (= 1 (cim_key_major chunkkey)) #t #f))
           (ckey (cim_key_root chunkkey))
           (size (cim_chunk_size chunk))
           (idx (cim_chunk_start_index chunk))
           (last-onset 0.0)
           (maj? (if (< *key* 0) #f #t))
           (key (if maj? *key* (modulo (* *key* -1) 12)))
           (scale (pc:scale key (if maj? 'ionian 'aeolian)))
           (note-not-played? #t))
      (if *osc:on*
          (begin
            (io:osc:send (*metro* beat) addy1 "/CIMdisplay/segs" (number->string num))
            (io:osc:send (*metro* beat) addy1 "/CIMdisplay/tempoPBS" 1)
            (io:osc:send (+ 5000 (*metro* beat)) addy1 "/CIMdisplay/tempoPBS" 0)))
      ;; (println)
      ;; (println 'diff: ckey cmaj? key maj?)
      (println '-----------------------)
      (println chunk)
      ;;(println)
      ;;(println 'scale: scale 'bpm: bpm)
      ;;(print_chunk_notes idx size)
      ;(get-pitches-from-chunk chunk)
      (transform-pitches (get-pitches-from-chunk chunk) chunkkey)
      ;; transpose into current key if required
      ;;(get-pitches-from-chunk chunk)
      ;;(println 'got-pitches)
      (if (= (cim_chunk_valid chunk) 1)
          (dotimes (i size)
            (if (and with-midicc? (< (real->integer (list-ref pitch-list i)) 0))
                     ;;note-not-played?)
                (let ((os (cim_chunk_note_onset chunk i)))
                  (play-midi-cc (if note-not-played?
                                    (now)
                                    (*metro* (+ last-onset os)))
                                *midi-out*
                                (* -1 (list-ref pitch-list i))
                                (cim_chunk_note_volume chunk i) 0))
                (if (>= (real->integer (list-ref pitch-list i)) 0)
                    (begin 
                      (if note-not-played? (set! last-onset (* -1 (cim_chunk_note_onset chunk i))))
                      (set! note-not-played? #f)
                      (let* ((os (cim_chunk_note_onset chunk i))
                             (mm (modulo os 0.125))
                             (mm2 (if (< mm .05) mm
                                      (if (> mm .1) (- mm .125)
                                          0.0))))
                        (println 'note: (cim_chunk_note_pitch chunk i)
                                 'beats: (cim_chunk_note_beats chunk i)
                                 'dur: (cim_chunk_note_duration chunk i))

                        ;; (println 'onset: os mm (- os mm2) mm2)
                        
                        ;; (play (+ 0.0 last-onset (if (< os .11) os (- os mm2))) fmsynth
                        ;;       ;(+ 12 (list-ref pitch-list i))
                        ;;        (pc:quantize (real->integer (+ 12 (- key ckey)
                        ;;                                      (list-ref pitch-list i)))
                        ;;                     scale)                          
                        ;;       (* 1.0 (cim_chunk_note_volume chunk i))
                        ;;       (* .7 (cim_chunk_note_duration chunk i)) 1.0 0.5)

                        (hplay (+ 0.0 last-onset (if (< os .11) os (- os mm2))) ;; quantise
                               inst
                               (pc:quantize (real->integer (+ (- key ckey)
                                                              (list-ref pitch-list i)))
                                            scale)
                               ;;(clamp (+ (* (/ (current_avg_velocity) 64) .5
                               ;;   (+ (cim_chunk_note_volume chunk i))) (random -10 10)) 10 127)
                               (clamp (+ (random 10) (/ (+ (current_avg_velocity) 
                                  (cim_chunk_note_volume chunk i)) 2)) 10 127)
                               (cim_chunk_note_duration chunk i))))
                    (begin
                      (if (> dcontrol 2)
                          (play-midi-cc (*metro* (+ (cim_chunk_note_onset chunk i) beat last-onset)) 
                                        *midi-out* (* -1 (list-ref pitch-list i)) (cim_chunk_note_volume chunk i) 0))
                      ))))))))


;; (define test)
;;   (let ((cnt 0) (allowreset #t))
;;     (lambda (beat dur)
;;       (println "test:" 'beat beat 'dur: dur 'tt: (- (*metro* (+ beat (* .125 dur))) (now)) 'time: (now) 'metro: (*metro* (+ beat (* .125 dur))) 'mark: (*metro* 'get-mark))
;;       (set! cnt (+ cnt 1))
;;       (set! total-beat beat)
;;       (let* ((maj? (if (< *key* 0) #f #t))
;;              (key (if maj? *key* (modulo (* *key* -1) 12)))
;;              (density_controller (real->integer (/ (cim_get_pedal 3) 25.0))))
;;         (if (and (> (cim_get_pedal 4) 10) allowreset)
;;             (begin
;;               (println "reset pedal")
;;               (set! allowreset #f)
;;               (reset_buffers)))
;;         (if (= 0 (cim_get_pedal 4))
;;             (begin
;;               (set! allowreset #t)))
;;         (if (> (cim_get_pedal 5) 0)
;;             (begin
;;               (if *osc:on*
;;                   (begin 
;;                     (io:osc:send (now) addy1 "/CIMdisplay/panicLED" 1)
;;                     (io:osc:send (+ (now) 10000) addy1 "/CIMdisplay/panicLED" 0)))
;;               (println "panic pedal")
;;               (panic *midi-out*)))
;;         ;; metronome 
;;         (playob 0 1 fmsynth (+ key 72) 70 (* .4 dur) 1.0 0.5)
;;         (playob 0 1 fmsynth (+ key 84) 50 (* .1 dur) 1.0 0.5)
;;         ;; (hplay (- 0 0.1) *midi-out* 96 40 0.1)        
;;         (if (> (cim_get_pedal 3) 0)
;;             (if (= 0 (modulo beat (list-ref '(16 8 4 3 2 1) density_controller)))
;;                 (begin
;;                   (play-chunk beat *midi-out* 1.5 (list-ref '(16 8 4 3 2 1) density_controller)))))
;;         (callback (*metro* (+ beat (* .125 dur))) 'test (+ beat dur) dur)))))

;; (test (*metro* 'get-beat 4) 1)

(define update-metro
  (lambda (bpm time beats)
    (set! *metro* (make-metro bpm (cons time beats)))))

(bind-func console_print
  (lambda (str:i8*)
    (ascii_text_color 1 0 3)
    (printf "%s \r" str)
    void))

(define lasttime 0)
(define lastbpm 120)


(define beat-loop
  (let ((cnt 0) (allowreset #t))  
    (lambda (beat dur)
      (set! *key* (current_key))
      (set! *pcs* (current-pcs))
      (set! *low* (current_pitch_range_low))
      (set! *high* (current_pitch_range_high))
      (set! *density* (current_density))
      (set! *polyphony* (current_polyphony_cnt))
      (set! *bpm* (current_bpm))
      ;;(print_rhythm_bins)
      (if *osc:on*
          (begin 
            (io:osc:send (*metro* beat) addy1 "/CIMdisplay/tempoLED" 1)
            (io:osc:send (+ 5000 (*metro* beat)) addy1 "/CIMdisplay/tempoLED" 0)    
            (io:osc:send (now) addy1 "/CIMdisplay/bpm" (number->string *bpm*))
            (io:osc:send (now) addy1 "/CIMdisplay/keyRoot" (list-ref (list "C" "C#" "D" "Eb" "E" "F" "F#" "G" "Ab" "A" "Bb" "B" "C") (abs *key*)))
            (io:osc:send (now) addy1 "/CIMdisplay/keyQuality" (if (< *key* 0) "Minor" "Major"))))
      (if (or (<> lasttime (get_phase_time))
              (<> lastbpm *bpm*))
          (begin
            (set! lasttime (get_phase_time))
            ;;(play-note (now) fmsynth 96 90 3000)
            (println "CHANGE METRO!" lasttime (*metro* beat) (now))
            ;; (callback (+ lasttime (* 2. *samplerate* (/ 60.0 *bpm*)))
            ;;           'update-metro (current_bpm)
            ;;           (+ lasttime (* 2. *samplerate* (/ 60.0 *bpm*)))
            ;;           (+ total-beat 1))))
            (callback (+ (*metro* beat) (* *samplerate* (/ 60.0 *bpm*)))
                      'update-metro (current_bpm)
                      (+ (*metro* beat) (* *samplerate* (/ 60.0 *bpm*)))
                      (+ total-beat 1))))
      (set! lastbpm *bpm*)
      (set! cnt (+ cnt 1))
      (set! total-beat beat)
      (let* ((maj? (if (< *key* 0) #f #t))
             (key (if maj? *key* (modulo (* *key* -1) 12)))
             (density_controller (real->integer (/ (cim_get_pedal 3) 25.0))))
        (if (and (> (cim_get_pedal 4) 10) allowreset)
            (begin
              (println "reset pedal")
              (set! allowreset #f)
              (reset_buffers)))
        (if (= 0 (cim_get_pedal 4))
            (begin
              (set! allowreset #t)))
        (if (> (cim_get_pedal 5) 0)
            (begin
              (if *osc:on*
                  (begin 
                    (io:osc:send (now) addy1 "/CIMdisplay/panicLED" 1)
                    (io:osc:send (+ (now) 10000) addy1 "/CIMdisplay/panicLED" 0)))
              (println "panic pedal")
              (panic *midi-out*)))
        ;; metronome
        ;; (if with_dsp?
        ;;     (begin 
        ;;       (playob 0 1 fmsynth (+ key 72) 70 (* .4 dur) 1.0 0.5)
        ;;       (playob 0 1 fmsynth (+ key 84) 50 (* .1 dur) 1.0 0.5)))
        ;; (hplay (- 0 0.1) *midi-out* 96 40 0.1)
        
        (if (> (cim_get_pedal 3) 2)
            (if (= 0 (modulo beat (list-ref '(16 8 4 3 2 1) density_controller)))
                (begin
                  (play-chunk beat *midi-out* 1.5 (list-ref '(16 8 4 3 2 1) density_controller))))))
      (callback (*metro* (+ beat (* 0.95 dur))) 'beat-loop (+ beat dur) dur))))

(beat-loop (*metro* 'get-beat 1) 1)

(define display-feedback
  (lambda ()
    (if *osc:on*
        (let ((density_controller (real->integer (/ (cim_get_pedal 3) 25.0))))
          (if (> (cim_get_pedal 1) 30)
              (io:osc:send (now) addy1 "/CIMdisplay/analyseLED" 1)
              (io:osc:send (now) addy1 "/CIMdisplay/analyseLED" 0))
          (if (> (cim_get_pedal 2) 30)
              (io:osc:send (now) addy1 "/CIMdisplay/recordLED" 1)
              (io:osc:send (now) addy1 "/CIMdisplay/recordLED" 0))
          (if (> (cim_get_pedal 3) 0)
              (io:osc:send (now) addy1 "/CIMdisplay/pbInt"
                           (list-ref '(16 8 4 3 2 1) density_controller))
              (io:osc:send (now) addy1 "/CIMdisplay/pbInt" 0))))
    (callback (+ (now) 4000) 'display-feedback)))

(display-feedback)

(cim_bpm_confidence_weight 2)

;; (cim_print_midi_messages 0)

(define reset_buffers
  (lambda ()
    (set! pitch-list '())    
    (note_buffer_reset)
    (if *osc:on*
        (begin
          (let ((num (total_chunks 1.5 0 0)))
            (io:osc:send (now) addy1 "/CIMdisplay/segs" (number->string num))
            (io:osc:send (now) addy1 "/CIMdisplay/flushLED" 1)
            (io:osc:send (+ (now) 25000) addy1 "/CIMdisplay/flushLED" 0))))
    (println "RESET BUFFERS")))

(reset_buffers)

;; density controller (half way)
(cim_set_pedal 3 100)

;; recording (always on)
(cim_set_pedal 2 127)

;; analysis (always off)
(cim_set_pedal 1 0)

;; setup a single initial section (zero indexed as always)
;; index 0, 120.0 bpm, 0 (C), #t Major
($ (set_cim_section 0 120.0 0 #t))

;; start sections off with initial call
(next_cim_section)
