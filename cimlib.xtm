;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CIM - Controlling Interactive Music
;;
;; Top Level Functions callable from scheme
;;
;; current_bpm
;; current_key
;; current_density
;; current_avg_velocity
;; current-pcs (a scheme wrapper for current_pcs)
;;
;; cim pedal 1 = analysis
;; cim pedal 2 = record
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load "libs/aot-cache/cimlib.xtm" 'quiet)
(sys:load-preload-check 'cimlib)
(define *xtmlib-cimlib-loaded* #f)

;; (impc:aot:suppress-aot-do
;;  (sys:load "libs/external/portmidi.xtm"))
;; (impc:aot:insert-forms (sys:load "libs/external/portmidi.xtm"))

;; (impc:aot:suppress-aot-do
;;  (sys:load "libs/core/math.xtm"))
;; (impc:aot:insert-forms (sys:load "libs/core/math.xtm"))

;; (sys:precomp:suppress-precomp-do
;;  (sys:load "libs/core/audio_dsp.xtm"))
;; (sys:precomp:insert-sexp '(sys:load "libs/core/audio_dsp.xtm"))
;; (sys:precomp:suppress-precomp-do
;;  (sys:load "libs/core/instruments.xtm"))
;; (sys:precomp:insert-sexp '(sys:load "libs/core/instruments.xtm"))

(impc:aot:insert-header "xtmcimlib")

(bind-val CIMSRd double 44100.0)
(bind-val CIMSR i64 44100)
;; (bind-val CIMSRd double (integer->real *au:samplerate*))
;;(bind-val CIM_PRINT_MIDI_MESSAGES i1 #t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; helpers for scheme
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-type CIMf64Array <i64,double*>)

(bind-func cim_f64_create
  (lambda (size)
    (let ((v:double* (halloc size)))
      (CIMf64Array size v))))

(bind-func cim_f64_size
  (lambda (a:CIMf64Array*)
    (tref a 0)))

(bind-func cim_f64_destroy
  (lambda (a:CIMf64Array*)
    (free (tref a 1))
    void))

(bind-func cim_f64_get
  (lambda (a:CIMf64Array* idx)
    (pref (tref a 1) (% idx (tref a 0)))))

(bind-func cim_f64_set
  (lambda (a:CIMf64Array* idx value)
    (pset! (tref a 1) (% idx (tref a 0)) value)))

(bind-func cim_f64_create
  (lambda (size)
    (let ((v:double* (halloc size)))
      (CIMf64Array size v))))

(bind-type CIMi64Array <i64,i64*>)

(bind-func cim_i64_create
  (lambda (size)
    (let ((v:i64* (halloc size)))
      (CIMi64Array size v))))

(bind-func cim_i64_size
  (lambda (a:CIMi64Array*)
    (tref a 0)))


(bind-func cim_i64_destroy
  (lambda (a:CIMi64Array*)
    (free (tref a 1))
    void))

(bind-func cim_i64_get
  (lambda (a:CIMi64Array* idx)
    (pref (tref a 1) (% idx (tref a 0)))))

(bind-func cim_i64_set
  (lambda (a:CIMi64Array* idx value)
    (pset! (tref a 1) (% idx (tref a 0)) value)))



;; Gaussian random
(bind-func randnd
  (let ((phase 0))
    (lambda ()
      (let ((u1:double (random))
            (u2:double (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (randnd)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))


(bind-func binomial_rng:[double]*
  (lambda ()
    (/ (+ (random) (random)) 2.0)))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; GLOBALS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-val CIM_GLOBAL_BPM double 120.0)
(bind-val CIM_GLOBAL_BPM_CONFIDENCE i64 0)
(bind-val CIM_GLOBAL_BPM_CONFIDENCE_WEIGHT i64 18)

(bind-func cim_bpm_confidence_weight
  (lambda (num)
    (set! CIM_GLOBAL_BPM_CONFIDENCE_WEIGHT num)
    void))

(bind-func current_bpm_confidence
  (lambda ()
    (clamp (/ (i64tod CIM_GLOBAL_BPM_CONFIDENCE)
              (i64tod CIM_GLOBAL_BPM_CONFIDENCE_WEIGHT))
           0.0 1.0)))



;;;;;;;;;;;;;; LinkTimelineEntry data type ;;;;;;;;;;;;;;;;;;;;;
;; An Ableton Link style 'Timeline' entry, i.e. a single identification of a beat with a time, and a tempo to hold sway until the next entry
;; note that time is measured in seconds, and tempo in beats per second
(bind-type LinkTimelineEntry <Rational,double,double> (constructor? . #f) (printer? . #f))

;; constructor
(bind-func LinkTimelineEntry:[LinkTimelineEntry*,Rational,double,double]*
  (lambda (beat time tempo)
    (let ((output:LinkTimelineEntry* (alloc)))
      (tfill! output beat time tempo)
      output)))

;; accessors
(bind-func beat:[Rational,LinkTimelineEntry*]* (lambda (ent) (tref ent 0)))
(bind-func beat:[Rational,LinkTimelineEntry*,Rational]* (lambda (ent value) (tset! ent 0 value)))
(bind-func time:[double,LinkTimelineEntry*]* (lambda (ent) (tref ent 1)))
(bind-func time:[double,LinkTimelineEntry*,double]* (lambda (ent value) (tset! ent 1 value)))
(bind-func tempo:[double,LinkTimelineEntry*]* (lambda (ent) (tref ent 2)))
(bind-func tempo:[double,LinkTimelineEntry*,double]* (lambda (ent value) (tset! ent 2 value)))


;;;;;;;;;;;;;;;;;;;;;; LinkTimeline data type ;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Timeline is an ordered collection of LinkTimelineEntry. Elements are array pointer, and array length
(bind-type LinkTimeline <LinkTimelineEntry*,i64> (printer? . #f) (constructor? . #f))
(bind-func LinkTimeline:[LinkTimeline*,LinkTimelineEntry*,i64]*
  (lambda (entryArrayPtr entryArrayLength)
    (let ((output:LinkTimeline* (alloc)))
      (tfill! output entryArrayPtr entryArrayLength)
      output)))

(bind-func entries:[LinkTimelineEntry*,LinkTimeline*]* (lambda (timeline) (tref timeline 0)))
(bind-func entries:[LinkTimelineEntry*,LinkTimeline*,LinkTimelineEntry*]* (lambda (timeline entries) (tset! timeline 0 entries)))
(bind-func length:[i64,LinkTimeline*]* (lambda (timeline) (tref timeline 1)))
(bind-func length:[i64,LinkTimeline*,i64]* (lambda (timeline lngth) (tset! timeline 1 lngth)))

(bind-func entry:[LinkTimelineEntry*,LinkTimeline*,i64]*
  (lambda (timeline:LinkTimeline* index:i64)
    (cond
     ((and (<= 0 index) (< index (length timeline)))
      (pref-ptr (entries timeline) index))
     (else (convert null)))))


(bind-func time:[double,LinkTimeline*,Rational,i64]*
  (lambda (timeline inBeat startIndex)
    (let ((loop:[i64,i64]*
           (lambda (index)
             (cond
              ((and (< index (length timeline)) (< (beat (entry timeline index)) inBeat))
               (loop (+ index 1)))
              (else index)))))
      (let ((q (loop startIndex)))
        (cond
         ((< 0 q)
          (let* ((p (- q 1))
                 (e:LinkTimelineEntry* (entry timeline p))
                 (b:Rational (beat:[Rational,LinkTimelineEntry*]* e))
                 (t:double (time:[double,LinkTimelineEntry*]* e))
                 (bps:double (tempo:[double,LinkTimelineEntry*]* e)))
            (+ t (xtm_division:[double,Rational,double]* (xtm_subtraction inBeat b) bps))))
         ((< 0 (length timeline))
          (let* ((e:LinkTimelineEntry* (entry timeline q))
                 (b:Rational (beat:[Rational,LinkTimelineEntry*]* e))
                 (t:double (time:[double,LinkTimelineEntry*]* e))
                 (bps:double (tempo:[double,LinkTimelineEntry*]* e)))
            (+ t (xtm_division:[double,Rational,double]* (xtm_subtraction inBeat b) bps))))
         (else
          (xtm_division:[double,Rational,double]* (xtm_multiplication:[Rational,Rational,i64]* inBeat 60) CIM_GLOBAL_BPM)))))))


(bind-func rational_approximation:[Rational,double,i64]*
  (lambda (x quantum)
    (cond
     ((>= x 0.0)
      (let* ((w:double (floor x))
             (r:double (- x w))
             (delta:double (/ 1.0 (i64tod quantum)))
             (loop:[i64,double,i64]*
              (lambda (y n)
                (cond
                 ((< y r)
                  (loop (+ y delta) (+ n 1)))
                 (else n)))))
        (let ((index:i64 (loop 0.0 0)))
          (let* ((g:double (* delta (i64tod index)))
                 (f:double (- g delta))
                 (a:double (- r f))
                 (b:double (- g r)))
            (if (< a b)
                (Rat (+ (* (dtoi64 w) quantum) (- index 1)) quantum)
                (Rat (+ (* (dtoi64 w) quantum) index) quantum))))))
     (else
      (xtm_multiplication:[Rational,Rational,i64]*
       (rational_approximation
        (* -1.0 x) quantum)
       -1)))))
             

(bind-func beat:[Rational,LinkTimeline*,double,i64]*
  (lambda (timeline inTime startIndex)
    (let ((loop:[i64,i64]*
           (lambda (index)
             (cond
              ((and (< index (length timeline)) (< (time (entry timeline index)) inTime))
               (loop (+ index 1)))
              (else index)))))
      (let ((q (loop startIndex)))
        (cond
         ((< 0 q)
          (let* ((p (- q 1))
                 (e:LinkTimelineEntry* (entry:[LinkTimelineEntry*,LinkTimeline*,i64]* timeline p))
                 (t:double (time:[double,LinkTimelineEntry*]* e))
                 (b:Rational (beat:[Rational,LinkTimelineEntry*]* e))
                 (bps:double (tempo e)))
            (xtm_addition:[Rational,Rational,Rational]* b (rational_approximation (* (- inTime t) bps) 256))))
         ((< 0 (length timeline))
          (let* ((e:LinkTimelineEntry* (entry timeline q))
                 (t:double (time:[double,LinkTimelineEntry*]* e))
                 (b:Rational (beat:[Rational,LinkTimelineEntry*]* e))
                 (bps:double (tempo e)))
            (xtm_addition b (rational_approximation (/ (- inTime t) bps) 256))))
         (else
          (rational_approximation (/ (* inTime 60.0) CIM_GLOBAL_BPM) 256)))))))



;; Global timeline
(bind-val cim_global_tempo_map LinkTimeline* (LinkTimeline null 0))


(bind-func set_bpm
  (lambda (value:double)
    (set! CIM_GLOBAL_BPM value)
    (set! cim_global_tempo_map (LinkTimeline (LinkTimelineEntry (Rat 0 1) 0.0 (/ CIM_GLOBAL_BPM 60.0)) 1))
    value))
    





;;;;;;;;;;;;;;;;  Pitch analysis functions such as range avoidance ;;;;;;;;;;;;;;;
(bind-val pitch_history_len i64 16)
(bind-val pitch_history |16,i64|)
(bind-val pitch_history_index i64 0)
;(bind-val pitch_hist_updated i64 0)

(bind-func get_pitch_history_len
	(lambda ()
		pitch_history_len))

(bind-func get_pitch_in_history
	(lambda (index:i64)
		(if (and (>= index 0) (< index pitch_history_len))
			(aref pitch_history index)
			0)))

;; store (modulo val 12) for pitch classes
(bind-func set_pitch_in_history
	(lambda (index:i64 val:i64)
		(if (and (>= index 0) (< index pitch_history_len))
			(aset! pitch_history index val)
			0)))

(bind-func set_next_pitch_in_history
	(lambda (val:i64)
		(aset! pitch_history pitch_history_index val)
		(set! pitch_history_index (modulo (+ pitch_history_index 1) pitch_history_len))))

(bind-val pitch_class_set_len i64 12)
(bind-val pitch_class_set CIMi64Array* (cim_i64_create pitch_class_set_len))
(bind-val pitch_class_set_index i64 0)

(bind-func get_pitch_class_set
	(lambda ()
		pitch_class_set))

;; this function puts -1 flags into all slots
;; overwrites those slots with pitch-classes members in the pitch history
(bind-func build_pcs
	(lambda ()
		(let ((i 0:i64))
			(dotimes (i pitch_class_set_len)
				(cim_i64_set pitch_class_set i -1)))
		(let ((i 0:i64))
			(dotimes (i pitch_history_len)
				(cim_i64_set pitch_class_set (modulo (get_pitch_in_history i) 12)
					(modulo (get_pitch_in_history i) 12))))))

;; An laternative that Inserts c maj triad pitches (this is a hack specifically for CIM)
;; use values 0-11 only for the triad pitch class arguments
(bind-func build_pcs_with_triad
	(lambda (p1:i64 p2:i64 p3:i64)
		(let ((i 0:i64))
			(dotimes (i pitch_class_set_len)
				(cim_i64_set pitch_class_set i -1)))
		(cim_i64_set pitch_class_set p1 p1)
		(cim_i64_set pitch_class_set p2 p2)
		(cim_i64_set pitch_class_set p3 p3)
		(let ((i 0:i64))
			(dotimes (i pitch_history_len)
				(cim_i64_set pitch_class_set (modulo (get_pitch_in_history i) 12)
					(modulo (get_pitch_in_history i) 12))))))

(build_pcs_with_triad 0 4 7)

;; scheme helper function - use to get the current pitch class list for pc-quantize
;; first line to build is a convenience and 'bakes in' the triad version of build
(define cim_pcs->list
  (lambda (a)
    ;(build_pcs_with_triad 0 4 7)
    (build_pcs)
    (let* ((size (cim_i64_size a))
          (lst '()))
			(dotimes (i 12)
				(if (> (cim_i64_get a i) -1)
					(set! lst (append lst (list (cim_i64_get a i))))))
      lst)))

;; if max or min functions return 0 then then history is empty, otherwise they return MIDI pitch numbers
(bind-func get_pitch_history_max
	(lambda ()
		(let ((i 1:i64)
					(max-p (get_pitch_in_history 0)))
	 			(dotimes (i pitch_history_len)
					(if (> (get_pitch_in_history i) max-p)
						(set! max-p (get_pitch_in_history i))))
				max-p)))

(bind-func get_pitch_history_min
	(lambda ()
		(let ((i 1:i64)
					(min-p (get_pitch_in_history 0)))
	 			(dotimes (i pitch_history_len)
					(if (and (< (get_pitch_in_history i) min-p) (> (get_pitch_in_history i) 0))
						(set! min-p (get_pitch_in_history i))))
				min-p)))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CONTROLLERS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-val CIM_PEDALS |10,i64|)

(bind-func cim_get_pedal
  (lambda (i:i64)
    (aref CIM_PEDALS i)))

(bind-func cim_set_pedal
  (lambda (i:i64 x:i64)
    (aset! CIM_PEDALS i x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CIMKey
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;;  root (as pc) and major/minor #t/#f
(bind-type CIMKey <i64,i1>)
(bind-val CIM_GLOBAL_KEY CIMKey)

(bind-func cim_key_root
  (lambda (key:CIMKey*)
    (if (null? key) -1
        (tref key 0))))

(bind-func cim_key_major
  (lambda (key:CIMKey*)
    (if (null? key) 0
        (tref key 1))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CIM_SECTIONS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-type CIMSection <i64,CIMKey,double>)
(bind-val CIM_GLOBAL_SECTIONS |100,CIMSection|)
(bind-val CIM_GLOBAL_MAX_SECTION i64 0)
(bind-val CIM_GLOBAL_CURRENT_SECTION i64 0)

(bind-func set_cim_section
  (lambda (idx bpm root:i64 maj_min:i1)
    (if (> (+ 1 idx) CIM_GLOBAL_MAX_SECTION)
        (set! CIM_GLOBAL_MAX_SECTION (+ 1 idx)))
    (if (>= idx 100)
        (begin (println "ERR: Global Seciton Max = 100!") void)
        (let ((sect (aref-ptr CIM_GLOBAL_SECTIONS idx))
              (key (tref-ptr sect 1)))
          (tfill! key root maj_min)
          (tset! sect 0 idx)
          (tset! sect 2 bpm)
          void))))

(bind-func get_cim_section_bpm
  (lambda (idx)
    (if (>= idx 100)
        (begin (println "ERR: Global Seciton Max = 100!") -1.0)
        (let ((sect (aref-ptr CIM_GLOBAL_SECTIONS idx)))
          (tref sect 2)))))

(bind-func get_cim_section_key
  (lambda (idx)
    (if (>= idx 100)
        (begin (println "ERR: Global Seciton Max = 100!") null)
        (let ((sect (aref-ptr CIM_GLOBAL_SECTIONS idx)))
          (tref-ptr sect 1)))))

(bind-func next_cim_section
  (lambda ()
    (if (or (>= CIM_GLOBAL_CURRENT_SECTION 100)
            (> CIM_GLOBAL_CURRENT_SECTION CIM_GLOBAL_MAX_SECTION))
        (begin (println "ERR: Global Seciton Max = " CIM_GLOBAL_MAX_SECTION " and absolute max is 100") void)
        (let ((sect (aref-ptr CIM_GLOBAL_SECTIONS CIM_GLOBAL_CURRENT_SECTION))
              (key (tref-ptr sect 1)))
          (set! CIM_GLOBAL_BPM (tref sect 2))
          (tset! CIM_GLOBAL_KEY 0 (tref key 0))
          (tset! CIM_GLOBAL_KEY 1 (tref key 1))
          (set! CIM_GLOBAL_CURRENT_SECTION (% (+ CIM_GLOBAL_CURRENT_SECTION 1) CIM_GLOBAL_MAX_SECTION))
          (println "Initializing BPM:" CIM_GLOBAL_BPM "in" (tref CIM_GLOBAL_KEY 0)
                   (if (tref CIM_GLOBAL_KEY 1) "major" "minor"))
          void))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; NOTE Buffer
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; index (0)
;; seconds-onset (1), seconds-duration (2),
;; pitch (3), volume (4), beats (5), bpm (6), key(7)
(bind-type CIMNote <i64,double,double,i64,i64,Rational,double,CIMKey>)
(bind-val CIMNoteBuffer |1000000,CIMNote|)
(bind-val CIMNoteBufferIdx i64 0)
(bind-val CIMNoteDurResolver |127,i64|)
(bind-val CIMNoteBufferStartTimeI i64 0)
(bind-val CIMNoteBufferStartTimeD double 0.0)

;; Analysis buffers
(bind-val CIMNoteGlobalClosureBuffer |1000000,double|)
;;(bind-val CIMNoteBeatOnsetBuffer |1000000,Rational|)
(bind-val CIMHighClosureIndices |1000000,i64|)
(bind-val CIMHighClosureIndicesCount i64)
(bind-val CIMGlobalClosureThreshold double 0.5)

(bind-val CIMGlobalGoodStartNotes |1000000,i64|)
(bind-val CIMGlobalGoodStartNotesCount i64)

(bind-val CIMGlobalGoodEndNotes |1000000,i64|)
(bind-val CIMGlobalGoodEndNotesCount i64)


(bind-val CIMGlobalLastChunkCandidateIndex i64 0)
(bind-val CIMGlobalChunkRepeatPeriod i64 1)
(bind-val CIMGlobalForbiddenRangeMin i64 0)
(bind-val CIMGlobalForbiddenRangeMax  i64 0)

(bind-val CIMGlobalPhraseInertiaSpread double 0.5)

(bind-func get-phrase-inertia-spread:[double]*
  (lambda ()
    (CIMGlobalPhraseInertiaSpread)))

(bind-func set-phrase-inertia-spread:[double,double]*
  (lambda (value)
    (set! CIMGlobalPhraseInertiaSpread value)))

(bind-func get-forbidden-range-min:[i64]*
  (lambda ()
    (CIMGlobalForbiddenRangeMin)))

(bind-func set-forbidden-range-min:[i64,i64]*
  (lambda (value)
    (set! CIMGlobalForbiddenRangeMin value)))

(bind-func get-forbidden-range-max:[i64]*
  (lambda ()
    (CIMGlobalForbiddenRangeMax)))

(bind-func set-forbidden-range-max:[i64,i64]*
  (lambda (value)
    (set! CIMGlobalForbiddenRangeMax value)))



(bind-func get-repeat-period:[i64]*
  (lambda ()
    (CIMGlobalChunkRepeatPeriod)))

(bind-func set-repeat-period:[i64,i64]*
  (lambda (value)
    (set! CIMGlobalChunkRepeatPeriod value)))


(bind-func cim_clear_good_start_notes
  (lambda ()
    (set! CIMGlobalGoodStartNotesCount 0)
    void))

(bind-func cim_clear_good_end_notes
  (lambda ()
    (set! CIMGlobalGoodEndNotesCount 0)
    void))


(bind-func cim_clear_high_closure_candidates
  (lambda ()
    (set! CIMHighClosureIndicesCount 0)
    (cim_clear_good_start_notes)
    (cim_clear_good_end_notes)
    void))


;; Checks whether a particular note index is currently listed as a high closure candidate (return true or false)
;; (bind-func cim_check_high_closure_candidate:[bool,i64]*
;;   (lambda (candidate:i64)
;;     (let ((loop
;;            (lambda (cc:i64)
;;              (if (<= CIMHighClosureIndicesCount cc)
;;                  #f
;;                  (if (= (aref CIMHighClosureIndices cc)  candidate)
;;                      #t
;;                      (loop (+ cc 1)))))))
;;       (loop 0))))


;; Checks whether a particular note index is currently listed as a high closure candidate
;; Returns position in CIMHighClosureIndices array of the candidate index if found, else returns -1
(bind-func cim_find_high_closure_candidate:[i64,i64]*
  (lambda (candidate:i64)
    (let ((loop
           (lambda (cc:i64)
             (if (<= CIMHighClosureIndicesCount cc)
                 -1
                 (if (= (aref CIMHighClosureIndices cc)  candidate)
                     cc
                     (loop (+ cc 1)))))))
      (loop 0))))


(bind-func cim_add_high_closure_candidate:[i64,i64]*
  (lambda (candidate)
    (cond
     ((< (cim_find_high_closure_candidate candidate) 0)
      (aset! CIMHighClosureIndices CIMHighClosureIndicesCount candidate)
      (set! CIMHighClosureIndicesCount (+ CIMHighClosureIndicesCount 1))
      1)
     (else -1))
    -1))
        

(bind-func cim_remove_high_closure_candidate:[i64,i64]*
  (lambda (candidate:i64)
    (let ((n:i64 (cim_find_high_closure_candidate candidate)))
      (cond
       ((<= 0 n)
        (let ((loop:[i64,i64]*
               (lambda (i:i64)
                 (cond
                  ((< i (- CIMHighClosureIndicesCount 1))
                   (aset! CIMHighClosureIndices i (aref CIMHighClosureIndices (+ i 1)))
                   (loop (+ i 1)))
                  (else 1)))))
          (loop n)
          (set! CIMHighClosureIndicesCount (- CIMHighClosureIndicesCount 1))))
       (else
        -1)))))


;;;
(bind-func cim_find_good_start_note:[i64,i64]*
  (lambda (candidate:i64)
    (let ((loop
           (lambda (cc:i64)
             (if (<= CIMGlobalGoodStartNotesCount cc)
                 -1
                 (if (= (aref CIMGlobalGoodStartNotes cc)  candidate)
                     cc
                     (loop (+ cc 1)))))))
      (loop 0))))


(bind-func cim_add_good_start_note:[i64,i64]*
  (lambda (good_index)
    (cond
     ((< (cim_find_good_start_note good_index) 0)
      (aset! CIMGlobalGoodStartNotes CIMGlobalGoodStartNotesCount good_index)
      (set! CIMGlobalGoodStartNotesCount (+ CIMGlobalGoodStartNotesCount 1))
      1)
     (else -1))
    -1))
        

(bind-func cim_remove_good_start_note:[i64,i64]*
  (lambda (candidate:i64)
    (let ((n:i64 (cim_find_good_start_note candidate)))
      (cond
       ((<= 0 n)
        (let ((loop:[i64,i64]*
               (lambda (i:i64)
                 (cond
                  ((< i (- CIMGlobalGoodStartNotesCount 1))
                   (aset! CIMGlobalGoodStartNotes i (aref CIMGlobalGoodStartNotes (+ i 1)))
                   (loop (+ i 1)))
                  (else 1)))))
          (loop n)
          (set! CIMGlobalGoodStartNotesCount (- CIMGlobalGoodStartNotesCount 1))))
       (else
        -1)))))



;;;
(bind-func cim_find_good_end_note:[i64,i64]*
  (lambda (candidate:i64)
    (let ((loop
           (lambda (cc:i64)
             (if (<= CIMGlobalGoodEndNotesCount cc)
                 -1
                 (if (= (aref CIMGlobalGoodEndNotes cc)  candidate)
                     cc
                     (loop (+ cc 1)))))))
      (loop 0))))


(bind-func cim_add_good_end_note:[i64,i64]*
  (lambda (good_index)
    (cond
     ((< (cim_find_good_end_note good_index) 0)
      (aset! CIMGlobalGoodEndNotes CIMGlobalGoodEndNotesCount good_index)
      (set! CIMGlobalGoodEndNotesCount (+ CIMGlobalGoodEndNotesCount 1))
      1)
     (else -1))
    -1))
        

(bind-func cim_remove_good_end_note:[i64,i64]*
  (lambda (candidate:i64)
    (let ((n:i64 (cim_find_good_end_note candidate)))
      (cond
       ((<= 0 n)
        (let ((loop:[i64,i64]*
               (lambda (i:i64)
                 (cond
                  ((< i (- CIMGlobalGoodEndNotesCount 1))
                   (aset! CIMGlobalGoodEndNotes i (aref CIMGlobalGoodEndNotes (+ i 1)))
                   (loop (+ i 1)))
                  (else 1)))))
          (loop n)
          (set! CIMGlobalGoodEndNotesCount (- CIMGlobalGoodEndNotesCount 1))))
       (else
        -1)))))



(bind-func random_index:[i64,i64]*
  (lambda (n:i64)
    (if (< 0 n)
        (dtoi64 (floor (* (i64tod n) (random))))
        -1)))


;; Timing
(bind-func cim_time:[double,i64]*
  (lambda (xt_lang_time)
    (/ (- (i64tod xt_lang_time) CIMNoteBufferStartTimeD) CIMSRd)))

(bind-func cim_current_time:[double]*
  (lambda ()
    (cim_time (now))))

(bind-func set_cim_start_time:[i64,i64]*
  (lambda (xt_lang_time)
    (set! CIMNoteBufferStartTimeI xt_lang_time)
    (set! CIMNoteBufferStartTimeD (i64tod CIMNoteBufferStartTimeI))
    (set! cim_global_tempo_map (LinkTimeline (LinkTimelineEntry (Rat 0 1) 0.0 (/ CIM_GLOBAL_BPM 60.0)) 1))
    CIMNoteBufferStartTimeI))
  

;; Note buffer
(bind-func cim_save_note_buffer
  (lambda (filename)
    (let ((fp (fopen filename "w"))
          (idx:i64* (salloc 1)))
      (pset! idx 0 CIMNoteBufferIdx)
      (if (null? fp)
          (begin (println "Failed to open file" (Str filename))
                 -1)
          (let ((data (cast CIMNoteBuffer i8*))
                (pos1 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 0))))
                (pos2 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 1))))
                (size (- pos2 pos1)))
            (if (< (fwrite (cast idx i8*) 8 1 fp) 0)
                (begin
                  (fclose fp)
                  (println "Failed to write to " (Str filename))
                  -1)
                (if (< (fwrite data size CIMNoteBufferIdx fp) 0)
                    (begin
                      (fclose fp)
                      (println "Failed to write to " (Str filename))
                      -1)
                    (begin
                      (fclose fp)
                      1))))))))


(bind-func cim_load_note_buffer
  (lambda (filename)
    (let ((fp (fopen filename "r"))
          (idx:i64* (salloc 1)))
      (if (null? fp)
          (begin (println "Failed to open file" (Str filename))
                 -1)
          (let ((data (cast CIMNoteBuffer i8*))
                (pos1 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 0))))
                (pos2 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 1))))
                (size (- pos2 pos1)))
            (if (= (fread (cast idx) 8 1 fp) 8)
                (begin
                  (fclose fp)
                  (println "Failed to load from " (Str filename))
                  -1)
                (if (= (fread data size (pref idx 0) fp) (* size (pref idx 0)))
                    (begin
                      (fclose fp)
                      (println "Failed to load from " (Str filename))
                      -1)
                    (begin
                      (set! CIMNoteBufferIdx (pref idx 0))
                      (fclose fp)
                      1))))))))


(bind-func init_dur_resolver
  (lambda ()
    (doloop (i 127)
      (aset! CIMNoteDurResolver i -1))
    void))

(init_dur_resolver)

(bind-func cim_note_index
  (lambda (note:CIMNote*)
    (if (null? note) -1
        (tref note 0))))

(bind-func cim_note_onset
  (lambda (note:CIMNote*)
    (if (null? note) -1.0
        (tref note 1))))

(bind-func cim_note_duration
  (lambda (note:CIMNote*)
    (tref note 2)))

(bind-func cim_note_set_duration
  (lambda (note:CIMNote* duration)
    (tset! note 2 duration)))

(bind-func cim_note_offset
  (lambda (note:CIMNote*)
    (+ (cim_note_onset note) (cim_note_duration note))))

(bind-func cim_note_pitch
  (lambda (note:CIMNote*)
    (tref note 3)))

(bind-func cim_note_volume
  (lambda (note:CIMNote*)
    (tref note 4)))

(bind-func cim_note_set_beats
  (lambda (note:CIMNote* beats:Rational)
    (tset! note 5 beats)))

(bind-func cim_note_beats
  (lambda (note:CIMNote*)
    (tref note 5)))

(bind-func cim_note_bpm
  (lambda (note:CIMNote*)
    (tref note 6)))

(bind-func cim_note_key
  (lambda (note:CIMNote*)
    (tref-ptr note 7)))

(bind-func cim_note_key_set
  (lambda (note:CIMNote* key majmin)
    (let ((cimkey (tref-ptr note 7)))
      (tset! cimkey 0 key)
      (tset! cimkey 1 majmin)
      note)))

(bind-func print:[void,CIMNote*]*
  (lambda (note)
    (if (null? note)
        (printout "<NOTE: NULL>")
        (printout "<NOTE: " (cim_note_index note)
                  " onset: " (cim_note_onset note)
                  " dur: " (cim_note_duration note)
                  " pitch: " (cim_note_pitch note)
                  " vol: " (cim_note_volume note)
                  " beats: " (cim_note_beats note)
                  " bpm: " (cim_note_bpm note)
                  " key: " (cim_note_key note)
                  ">"))
    void))

(bind-func retrieve_note
  (lambda (idx)
    (if (or (< idx 0)
            (>= idx CIMNoteBufferIdx))
        null
        (aref-ptr CIMNoteBuffer idx))))

(bind-func last_note
  (lambda ()
    (if (= 0 CIMNoteBufferIdx) null
        (aref-ptr CIMNoteBuffer (- CIMNoteBufferIdx 1)))))

(bind-func last_note_index
  (lambda ()
    (- CIMNoteBufferIdx 1)))

(bind-func note_buffer_reset
  (lambda ()
    ;;(memset (cast CIMNoteBuffer) 0 (* 1000000 40))
    (set! CIMGlobalChunkRepeatPeriod 1)
    (set! CIMGlobalLastChunkCandidateIndex 0)
    (cim_clear_high_closure_candidates)
    (set-forbidden-range-min 0)
    (set-forbidden-range-max 0)
    (set! CIMNoteBufferIdx 0)
    (set_cim_start_time 0)))

(bind-func dump_note_buffer
  (lambda ()
    (doloop (i CIMNoteBufferIdx)
      (println (retrieve_note i)))))

(bind-func dump_note_closures:[void]*
  (lambda ()
    (println "---- Note Closures ----")
    (doloop (i CIMNoteBufferIdx)
      (printout (aref CIMNoteGlobalClosureBuffer i))
      (if (< i (- CIMNoteBufferIdx 1))
          (printout ", ")
          (println "")))
    void))


(bind-func dump_high_closure_candidates:[void]*
  (lambda ()
   (println "---- High Closure Candidates ----")
    (doloop (i CIMHighClosureIndicesCount)
      (printout (aref CIMHighClosureIndices  i))
      (if (< i (- CIMHighClosureIndicesCount 1))
          (printout ", ")
          (println "")))
    void))

(bind-func find_note
  (lambda (timea timeb)
    (let ((idx 0)
          (note (retrieve_note idx)))
      (while (and (not (null? note))
                  (or (< (cim_note_onset note) timea)
                      (> (cim_note_onset note) timeb)))
        (set! idx (+ idx 1))
        (set! note (retrieve_note idx)))
      note)))

(bind-func find_note
  (lambda (timea)
    (find_note:[CIMNote*,double,double]* timea timea)))

(bind-func find_note
  (lambda (timea pitch)
    (let ((idx 0)
          (note (retrieve_note idx)))
      (while (and (not (null? note))
                  (or (< (cim_note_onset note) timea)
                      (<> (cim_note_pitch note) pitch)))
        (set! idx (+ idx 1))
        (set! note (retrieve_note idx)))
      note)))

;; valid, start note, finish note, size, onset, duration, bpm, homophonic(%)
(bind-type CIMChunk <i1,CIMNote*,CIMNote*,i64,double,double,double,double>)

(bind-func cim_chunk_copy
  (lambda (c1:CIMChunk* c2:CIMChunk*)
    (tfill! c2
            (tref c1 0)
            (tref c1 1)
            (tref c1 2)
            (tref c1 3)
            (tref c1 4)
            (tref c1 5)
            (tref c1 6)
            (tref c1 7))))

(bind-func cim_chunk_valid
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) #f
        (tref chunk 0))))

(bind-func cim_chunk_invalidate
  (lambda (chunk:CIMChunk*)
    (tset! chunk 0 #f)
    void))


(bind-func cim_chunk_start
  (lambda (chunk:CIMChunk*)
    (tref chunk 1)))

(bind-func cim_chunk_end
  (lambda (chunk:CIMChunk*)
    (tref chunk 2)))

(bind-func cim_chunk_start_index
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0
      (cim_note_index (tref chunk 1)))))

(bind-func cim_chunk_end_index
  (lambda (chunk:CIMChunk*)
    (cim_note_index (tref chunk 2))))

(bind-func cim_chunk_size
  (lambda (chunk:CIMChunk*)
    (if (null? chunk)
        0
        (tref chunk 3))))

(bind-func cim_chunk_onset
  (lambda (chunk:CIMChunk*)
    (if (null? chunk)
        0.0
        (tref chunk 4))))

(bind-func cim_chunk_duration
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0.0
        (tref chunk 5))))

(bind-func cim_chunk_bpm
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0.0
        (tref chunk 6))))

(bind-func cim_chunk_homophonic
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0.0
        (tref chunk 7))))

(bind-func cim_chunk_key
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) null
        (cim_note_key (cim_chunk_start chunk)))))

;; percentage of overlapping notes
(bind-func set_chunk_homophonic_percentage
  (lambda (chunk:CIMChunk*)
    (let ((num (cim_chunk_size chunk))
          (i 0)
          (onset 0.0)
          (duration 0.0)
          (cnt:i64 0)
          (note:CIMNote* null)
          (idx (cim_note_index (cim_chunk_start chunk))))
      (set! cnt 0)
      (set! onset 0.0)
      (set! duration 0.0)
      (dotimes (i idx num)
        (set! note (retrieve_note i))
        (if (and (>= (cim_note_onset note) onset)
                 (< (cim_note_onset note) duration))
            (set! cnt (+ cnt 1)))
        (set! onset (cim_note_onset note))
        (set! duration (+ onset (* 0.75 (cim_note_duration note)))))
      (tset! chunk 7 (/ (i64tod cnt) (i64tod num)))
      void)))

(bind-func cim_chunk_note_onset
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (chunkbpm (cim_chunk_bpm chunk))
          (onset (cim_chunk_onset chunk))
          (note (retrieve_note (+ sidx idx))))
      (* (- (cim_note_onset note) onset) (/ chunkbpm 60.0)))))

(bind-func cim_chunk_note_beats
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (chunkbpm (cim_chunk_bpm chunk))
          (note (retrieve_note (+ sidx idx))))
      (rtod (cim_note_beats note)))))

(bind-func cim_chunk_note_duration
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (chunkbpm (cim_chunk_bpm chunk))
          (note (retrieve_note (+ sidx idx))))
      (* (cim_note_duration note) (/ chunkbpm 60.0)))))

(bind-func cim_chunk_note_pitch
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (note (retrieve_note (+ sidx idx))))
      (cim_note_pitch note))))

(bind-func cim_chunk_note_index
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (note (retrieve_note (+ sidx idx))))
      (cim_note_index note))))

(bind-func cim_chunk_note_volume
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (note (retrieve_note (+ sidx idx))))
      (cim_note_volume note))))

(bind-func cim_chunk_note_pitches
  (lambda (chunk:CIMChunk*)
    (let ((num (cim_chunk_size chunk))
          (i 0)
          (a (cim_i64_create num)))
      (dotimes (i num)
        (cim_i64_set a i (cim_chunk_note_pitch chunk i)))
      a)))

(bind-func cim_chunk_note_volumes
  (lambda (chunk:CIMChunk*)
    (let ((num (cim_chunk_size chunk))
          (i 0)
          (a (cim_i64_create num)))
      (dotimes (i num)
        (cim_i64_set a i (cim_chunk_note_volume chunk i)))
      a)))

(bind-func cim_chunk_note_durations
  (lambda (chunk:CIMChunk*)
    (let ((num (cim_chunk_size chunk))
          (i 0)
          (a (cim_f64_create num)))
      (dotimes (i num)
        (cim_f64_set a i (cim_chunk_note_duration chunk i)))
      a)))

;; I know beatss ;)
(bind-func cim_chunk_note_beatss
  (lambda (chunk:CIMChunk*)
    (let ((num (cim_chunk_size chunk))
          (i 0)
          (a (cim_f64_create num)))
      (dotimes (i num)
        (cim_f64_set a i (cim_chunk_note_beats chunk i)))
      a)))

(bind-func cim_chunk_note_onsets
  (lambda (chunk:CIMChunk*)
    (let ((num (cim_chunk_size chunk))
          (i 0)
          (a (cim_f64_create num)))
      (dotimes (i num)
        (cim_f64_set a i (cim_chunk_note_onset chunk i)))
      a)))


(bind-func cim_chunk_start_beatclass
  (lambda (chunk)
    (let* ((note:CIMNote* (cim_chunk_start chunk))
           (onset:double (cim_note_onset note)))
      (modulo onset 1.0))))
           
          


(bind-func print:[void,CIMChunk*]*
  (lambda (chunk)
    (if (null? chunk)
        (printout "<CHUNK: NULL>")
        (begin
          (printout "<CHUNK: valid: " (cim_chunk_valid chunk)) ;; " onset: " (cim_note_onset (cim_chunk_start chunk)))
          (printout "\nstart  : " (cim_note_onset (cim_chunk_start chunk)) " idx: " (cim_note_index (cim_chunk_start chunk)))
          (printout "\nend    : " (cim_note_onset (cim_chunk_end chunk)) " idx: " (cim_note_index (cim_chunk_end chunk)))
          (printout "\nnotes  : " (cim_chunk_size chunk))
          (printout "\nonset  : " (cim_chunk_onset chunk))
          (printout "\nbpm    : " (cim_chunk_bpm chunk))
          (printout "\nkey    : " (cim_key_root (cim_chunk_key chunk)) " maj? " (cim_key_major (cim_chunk_key chunk)))
          (printout "\nhomo   : " (dtoi64 (* 100. (cim_chunk_homophonic chunk))) " %")
          (printout "\ndur    : " (cim_chunk_duration chunk) ">")))
    void))


(bind-func scheme-chunk-print:[void,i8*]*
  (lambda (ptr)
    (let ((chunk:CIMChunk* (cast ptr CIMChunk*)))
      (print chunk)
      void)))

(bind-val CIMDefaultGapSize double 2.0)

(bind-func setCIMDefaultGapSize
  (lambda (val:double)
    (set! CIMDefaultGapSize val)))

(bind-func getCIMDefaultGapSize
  (lambda (val:double)
    CIMDefaultGapSize))

(setCIMDefaultGapSize 1.0)

;; (bind-func cim_note_closure
;;   (lambda (a:CIMNote* b:CIMNote* c:CIMNote*)
;;     (if (or (null? a) (null? b) (null? c)) #f
;;         (let ((key (cim_note_key a))
;;               (root (tref key 0))
;;               (majmin (tref key 1))
;;               (p1 (cim_note_pitch a))
;;               (p2 (cim_note_pitch b))
;;               (p3 (cim_note_pitch c))
;;               (p312 (% p3 12))
;;               (i1 (- p2 p1))
;;               (i2 (- p3 p2))
;;               (d1 (cim_note_duration a))
;;               (d2 (cim_note_duration b))
;;               (d3 (cim_note_duration c))
;;               (t1 (* (- d3 d2) 5.0)) ;; test1 d3 is longer than d2
;;               (t2 (if (or (and (> i1 0) (< i2 0))
;;                           (and (< i1 0) (> i2 0))) ;; test2 change in direction
;;                       10.0   ;; change in direction
;;                       0.0))  ;; or not
;;               (t3 (if (> (* i1 i1) (* i2 i2)) 10.0 0.0)) ;; test3 large to small interval
;;               (t4 (if (= root p312) 10.0 ;; test4 (finishes on root=10.0 3rd=5.0 5th=5.0)
;;                       (if (= (% (+ 7 root) 12) p312) 5.0 ;; 7th
;;                           (if (= (% (+ (if majmin 4 3) root) 12) p312) 5.0 ;; 3rd
;;                               0.0))))) ;; else 0.0

;;           (if (> (+ t1 t2 t3 t4) 25.0)
;;               (println "closure" t1 t2 t3 t4 (+ t1 t2 t3 t4) p1 p2 p3))
;;           (if (> (+ t1 t2 t3 t4) 25.0)
;;               #t
;;               #f)))))


;; ;; Retrospective Closure includes the previous two notes and the succeeding note
;; (bind-func cim_note_closure:[double,CIMNote*,CIMNote*,CIMNote*,CIMNote*]*
;;   (lambda (nn:CIMNote* n:CIMNote* x:CIMNote* s:CIMNote*)
;;     (cond
;;       ((or (null? nn) (null? n) (null? x) (null? s)) 0.0
;;         (let* ((key (cim_note_key x))
;;               (root (tref key 0))
;;               (majmin (tref key 1))
;;               (p1 (cim_note_pitch nn))
;;               (p2 (cim_note_pitch n))
;;               (p3 (cim_note_pitch x))
;;               (p312 (% p3 12))
;;               (i1 (- p2 p1))
;;               (i2 (- p3 p2))
;;               (onset_nn (cim_note_onset nn))
;;               (onset_n (cim_note_onset n))
;;               (onset_x (cim_note_onset x))
;;               (onset_s (cim_note_onset s))
;;               (ioi1 (- onset_n onset_nn))
;;               (ioi2 (- onset_x onset_n))
;;               (ioi3 (- onset_s onset_x))
;;               (t1 (if (< ioi2 ioi3) (clamp (/ ioi3 ioi2) 0.0 4.0) 0.0)) ;; test1 ioi3 is longer than ioi2
;;               (t2 (if (or (and (> i1 0) (< i2 0)) (and (< i1 0) (> i2 0))) ;; test2 change in direction
;;                       2.0   ;; change in direction
;;                       0.0))  ;; or not
;;               (t3 (if (> (* i1 i1) (* i2 i2)) 10.0 0.0)) ;; test3 large to small interval
;;               (t4 (if (= root p312) 10.0 ;; test4 (finishes on root=10.0 3rd=5.0 5th=5.0)
;;                       (if (= (% (+ 7 root) 12) p312) 5.0 ;; 5th
;;                           (if (= (% (+ (if majmin 4 3) root) 12) p312) 5.0 ;; 3rd
;;                               0.0))))) ;; else 0.0
;;           (+ t1 t2 t3 t4)))))

(bind-func log2:[double,double]*
  (lambda (x)
    (/ (log x) (log 2.0))))

(bind-func metric_weight:[double,double]*
  (lambda (time)
    (let* ((r:Rational (Rational_reduce (rational_approximation time 16)))
           (d:i64 (tref r 1))
           (c:double (log2 (i64tod d))))
      (/ 1.0 (+ c 1.0)))))
           
(bind-func tonal_stability:[double,CIMNote*,CIMKey*]*
  (lambda (x:CIMNote* key:CIMKey*)
    (let* ((root (tref key 0))
           (majmin (tref key 1))
           (pitch (cim_note_pitch x))
           (pitch_class (% pitch 12)))
      (if (= root pitch_class) 1.0 ;; tonic
          (if (= (% (+ 7 root) 12) pitch_class) 0.5 ;; 5th
              (if (= (% (+ (if majmin 4 3) root) 12) pitch_class) 0.25 ;; 3rd
                  0.0))) ;; else 0.0
      )))
       

;; Zeroth order closure - longer and more tonally stable = more closed
;; NOTE that this function is different to those that follow, in that it matters
;; *when* this function is called. It is only needed when there is only a
;; single note in the database.
(bind-func cim_isolated_note_closure:[double,CIMNote*,double]*
  (lambda (x:CIMNote* currentTime:double)
    (let* ((onset_x (cim_note_onset x))
           (gap:double (- currentTime onset_x))
           (t1:double
            (if (< 0.0 CIMDefaultGapSize)
                (min (/ gap CIMDefaultGapSize) 1.0)
                1.0))
           (t2:double 0.0)
           (t3:double (metric_weight onset_x))
           (t4:double (tonal_stability x (cim_note_key x))))
          (/ (+ t1 t2 t3 t4) 4.0))))

;; First order closure, also dependent on the current time.
(bind-func cim_second_of_two_notes_closure:[double,CIMNote*,CIMNote*,double]*
  (lambda (n:CIMNote* x:CIMNote* currentTime:double)
    (let* ((onset_n (cim_note_onset n))
           (onset_x (cim_note_onset x))
           (gap:double (- currentTime onset_x))
           (t1:double
            (if (< 0.0 CIMDefaultGapSize)
                (min (/ gap CIMDefaultGapSize) 1.0)
                1.0))
           (t2:double 0.0)
           (t3:double (max (- (metric_weight onset_x) (metric_weight onset_n)) 0.0))
           (t4:double (max (- (tonal_stability x (cim_note_key x)) (tonal_stability n (cim_note_key x))) 0.0)))
          (/ (+ t1 t2 t3 t4) 4.0))))


(bind-func cim_first_of_two_notes_closure:[double,CIMNote*,CIMNote*]*
  (lambda (x:CIMNote* s:CIMNote*)
    (let* ((onset_x (cim_note_onset x))
           (onset_s (cim_note_onset s))
           (gap:double (- onset_s onset_x))
           (t1:double
            (if (< 0.0 CIMDefaultGapSize)
                (min (/ gap CIMDefaultGapSize) 1.0)
                1.0))
           (t2:double 0.0)
           (t3:double (metric_weight onset_x))
           (t4:double (tonal_stability x (cim_note_key x))))
          (/ (+ t1 t2 t3 t4) 4.0))))


(bind-func cim_note_closure_normal
  (lambda (n:CIMNote* x:CIMNote* s:CIMNote*)
    (let* ((onset_n (cim_note_onset n))
           (onset_x (cim_note_onset x))
           (onset_s (cim_note_onset s))
           (ioi1:double (- onset_x onset_n))
           (ioi2:double (- onset_s onset_x))
           (gap:double (- onset_s onset_x))
           (t1:double
            (if (< 0.0 CIMDefaultGapSize)
                (min (/ gap CIMDefaultGapSize) 1.0)
                1.0))
           (t2:double
            (/ (if (< 0.0 ioi1)
                   (min (/ ioi2 ioi1) 4.0)
                   4.0)
               4.0))
           (t3:double (max (- (metric_weight onset_x) (metric_weight onset_n)) 0.0))
           (t4:double (max (- (tonal_stability x (cim_note_key x)) (tonal_stability n (cim_note_key x))) 0.0)))
      (/ (+ t1 t2 t3 t4) 4.0))))


;; Retrospective Closure includes the previous two notes and the succeeding note
(bind-func cim_note_closure:[double,CIMNote*,CIMNote*,CIMNote*,double]*
  (lambda (n:CIMNote* x:CIMNote* s:CIMNote* currentTime:double)
    (let ((t1:double 0.0) (t2:double 0.0) (t3:double 0.0) (t4:double 0.0))
      (cond
       ((null? x) 0.0)
       ((and (null? n) (null? s))
        (cim_isolated_note_closure x currentTime))
       ((null? n)
        (cim_first_of_two_notes_closure x s))
       ((null? s)
        (cim_second_of_two_notes_closure n x currentTime))
       (else
        (cim_note_closure_normal n x s))))))


(bind-func is_good_start_note:[bool,CIMNote*,CIMNote*,CIMNote*,double]*
  (lambda (n:CIMNote* x:CIMNote* s:CIMNote* currentTime:double)
    (cond
     ((null? x) #f)
     ((and (null? n) (null? s)) #f)
     ((null? n) #t)
     ((null? s) #f)
     ((= (cim_note_duration x) 0.0) #f)
     ((< CIMDefaultGapSize (- (cim_note_onset s) (cim_note_offset x))) #f)
     (else #t))))


(bind-func is_good_start_note:[bool,i64]*
  (lambda (index)
    (let ((note_n:CIMNote* (retrieve_note (- index 1)))
          (note_x:CIMNote* (retrieve_note index))
          (note_s:CIMNote* (retrieve_note (+ index 1)))
          (currentTime:double (cim_current_time)))
      (is_good_start_note:[bool,CIMNote*,CIMNote*,CIMNote*,double]* note_n note_x note_s currentTime))))


(bind-func is_good_end_note:[bool,CIMNote*,CIMNote*,CIMNote*,double]*
  (lambda (n:CIMNote* x:CIMNote* s:CIMNote* currentTime:double)
    (cond
     ((null? x) #f)
     ((and (null? n) (null? s)) #f)
     ((null? n) #f)
     ((null? s) #t)
     ((= (cim_note_duration x) 0.0) #f)
     ((< CIMDefaultGapSize (- (cim_note_onset s) (cim_note_offset x))) #t)
     (else #f))))


(bind-func is_good_end_note:[bool,i64]*
  (lambda (index)
    (let ((note_n:CIMNote* (retrieve_note (- index 1)))
          (note_x:CIMNote* (retrieve_note index))
          (note_s:CIMNote* (retrieve_note (+ index 1)))
          (currentTime:double (cim_current_time)))
      (is_good_end_note:[bool,CIMNote*,CIMNote*,CIMNote*,double]* note_n note_x note_s currentTime))))




(bind-func update_closures:[i64,i64,double]*
  (lambda (index:i64 currentTime:double)
    (let ((note_n (retrieve_note (- index 1)))
          (note_x (retrieve_note index))
          (note_s (retrieve_note (+ index 1))))
      (cond
       ((and (<= 0 index) (< index CIMNoteBufferIdx))
        (let ((c:double (cim_note_closure note_n note_x note_s currentTime)))
          (aset! CIMNoteGlobalClosureBuffer index
                 (cim_note_closure note_n note_x note_s currentTime))
          (cond
           ((<= CIMGlobalClosureThreshold c)
            (cim_add_high_closure_candidate index)
            (if (is_good_start_note note_n note_x note_s currentTime) (cim_add_good_start_note index))
            (if (is_good_end_note note_n note_x note_s currentTime) (cim_add_good_end_note index)))
            (else
             (cim_remove_high_closure_candidate index)
             (cim_remove_good_start_note index)
             (cim_remove_good_end_note index)
             )))
        (update_closures (+ index 1) currentTime))
       (else index)))))
           
(update_closures 0 (cim_current_time))
(dump_note_closures)
(dump_high_closure_candidates)
($ (print (retrieve_note 6)))


;;;;;;;;;; TODO finish implementing ;;;;;;;
;; (bind-func onset_in_beats
;;   (lambda (index:i64)
;;     (cond
;;      ((= index 0)
;;       (let ((n (retrieve_note 0)))
;;         (if (null? n)
;;             (Rational 0 -1)))))))
            
;;      ((and (< 0 index) (< index CIMNoteBufferIdx))
;;       (let ((pb (onset_in_beats (- index 1)))
;;             (pn (retrieve_note (- index 1)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      


(bind-func cim_chunk_min_pitch
  (lambda (chunk:CIMChunk*)
    (let* ((lower:i64 127)
           (startIndex (cim_chunk_start_index chunk))
           (endIndex (cim_chunk_end_index chunk))
           (loop:[i64,i64]*
            (lambda (index:i64)
              (cond
               ((<= index endIndex)
                (let ((p:i64 (cim_note_pitch (retrieve_note index))))
                   (if (< p lower) (set! lower p)))
                (loop (+ index 1)))
               (else lower)))))
      (loop startIndex))))

      
(bind-func cim_chunk_max_pitch
  (lambda (chunk:CIMChunk*)
    (let* ((upper:i64 0)
           (startIndex (cim_chunk_start_index chunk))
           (endIndex (cim_chunk_end_index chunk))
           (loop:[i64,i64]*
            (lambda (index:i64)
              (cond
               ((<= index endIndex)
                (let ((p:i64 (cim_note_pitch (retrieve_note index))))
                   (if (> p upper) (set! upper p)))
                (loop (+ index 1)))
               (else upper)))))
      (loop startIndex))))
      

(bind-func new_find_chunk:[CIMChunk*,double,i64,i64,i64]*
  (let ((chunk:CIMChunk* (alloc)))
    (lambda (max_length_in_beats:double minForbiddenPitch:i64 maxForbiddenPitch:i64 attempt:i64)
      ;; Search through global closure values for starting points
      ;;(println "--- Searching for suitable chunk ---")
      (tset! chunk 0 #f)
      (cond
       ((< 0 CIMNoteBufferIdx)
        (set! CIMGlobalLastChunkCandidateIndex (max 0 (min (+ CIMGlobalLastChunkCandidateIndex (dtoi64 (round (* CIMGlobalPhraseInertiaSpread (randnd))))) (- CIMGlobalGoodStartNotesCount 1))))
        (let ((startIndex:i64
               (if (and (< 0 CIMGlobalLastChunkCandidateIndex) (< CIMGlobalLastChunkCandidateIndex CIMGlobalGoodStartNotesCount))
                   (min (+ (aref CIMGlobalGoodStartNotes CIMGlobalLastChunkCandidateIndex) 0) CIMNoteBufferIdx)
                   (random_index CIMNoteBufferIdx)))
              (startNote:CIMNote* (retrieve_note startIndex))
              (startOnset:double (cim_note_onset startNote))
              (start_onset_beat:Rational (beat cim_global_tempo_map (cim_note_onset startNote) 0))
              (maxValue:double 0.0)
              (maxIndex:i64 startIndex)
              (loop:[i64,i64,i64]*
               (lambda (index:i64 cc:i64)
                 (cond
                  ((< index CIMNoteBufferIdx)
                   (let ((c:double (* (i64tod cc) (aref CIMNoteGlobalClosureBuffer index)))
                         (end_onset_beat:Rational (beat cim_global_tempo_map (cim_note_onset (retrieve_note index)) 0))
                         (lb:Rational (xtm_subtraction end_onset_beat start_onset_beat)))
                     (cond
                      ((<= (rtod lb) max_length_in_beats)
                       (if (<= maxValue c) (begin (set! maxValue c) (set! maxIndex index)))
                       (loop (+ index 1) (+ cc 1)))
                      (else index))))
                  (else index)))))
          (loop startIndex 0)
          ;;(println "Selected candidate " CIMGlobalLastChunkCandidateIndex " which is note index " startIndex " with endIndex " maxIndex)
          (let* ((endIndex maxIndex)
                 (endNote (retrieve_note endIndex))
                 (endOnset (cim_note_onset endNote))
                 (end_dur (cim_note_duration endNote))
                 (chunk_dur (- (+ endOnset end_dur) startOnset)))
            (tfill! chunk #t startNote endNote (+ 1 (- endIndex startIndex)) startOnset chunk_dur CIM_GLOBAL_BPM 0.0)
            (set_chunk_homophonic_percentage chunk)
            (let ((min_pitch (cim_chunk_min_pitch chunk))
                  (max_pitch (cim_chunk_max_pitch chunk)))
              (if (or (< max_pitch minForbiddenPitch) (> min_pitch maxForbiddenPitch) (> attempt 5))
                  chunk
                  (new_find_chunk max_length_in_beats minForbiddenPitch maxForbiddenPitch (+ attempt 1)))))))
       (else
        ;;(println "---- The note database is currently empty, so no valid chunk could be found")
        (tset! chunk 0 #f)
        chunk)))))
 




;;;;;;;;;;;;;;;;;;;;;;;;;;;; mega commented out block ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ;; where startidx is note index to start searching from
;; ;; and endidx is the number of notes to check over
;; ;; if endidx is negative then start from startidx and work backwards
;; ;;
;; ;; if gapsize > 0.0 split based on gapsize
;; ;; if gapsize == 0.0 then split based on elements of closure.
;; (bind-func find_chunk
;;   (let ((chunk:CIMChunk* (alloc)))
;;     (lambda (chunk_num:i64 gapsize:double startidx:i64 endidx:i64)
;;       ;; (println "in find chunk a: " chunk_num)
;;       (tset! chunk 0 #f)
;;       (let ((duration 0.0)
;;             (backward (if (< endidx 0) #t #f))
;;             (inc (if (< endidx 0) -1 1))
;;             (startnote (retrieve_note startidx))
;;             (bpm 120.0)
;;             (ptime 0.0)
;;             (finished #f)
;;             (note (retrieve_note startidx)))
;;         ;; (println "findchk:")
;;         ;; (println "startnote: " startnote)
;;         ;; (println "note: " note)
;;         ;; (println "KKK")
;;         (while (and (not (null? note))
;;                     (not finished))
;;           (if (if backward
;;                   (> (- ptime (+ (cim_note_onset note) (cim_note_duration note))) gapsize)
;;                   (> (- (cim_note_onset note) ptime) gapsize))
;;               (begin
;;                 (set! chunk_num (- chunk_num 1))
;;                 (if (= chunk_num 0)
;;                     (begin (set! finished #t)
;;                            (set! startidx (+ startidx (* -1 inc)))
;;                            void)
;;                     (begin (set! startidx (+ startidx 0))
;;                            (set! startnote note)
;;                            ;(set! oldnote2 null)
;;                            ;(set! oldnote1 null)
;;                            void)))
;;               (begin
;;                 (set! startidx (+ startidx inc)) void))
;;           (set! ptime
;;                 (if backward
;;                     (cim_note_onset note)
;;                     (+ (cim_note_onset note) (cim_note_duration note))))
;;           (set! note (retrieve_note startidx)))
;;         (if (and (null? note) (< chunk_num 2))
;;             (begin
;;               (set! finished #t)
;;               (set! note (last_note))))
;;         (if (or (not finished) (null? note) (null? startnote))
;;             null
;;             (begin
;;               (set! duration 0.0)
;;               (set! bpm (cim_note_bpm startnote))
;;               (set! duration (- (+ (cim_note_onset note)
;;                                    (cim_note_duration note))
;;                                 (cim_note_onset startnote)))
;;               (tfill! chunk finished
;;                       startnote
;;                       note
;;                       (+ 1 (- (cim_note_index note) (cim_note_index startnote)))
;;                       (cim_note_onset startnote)
;;                       duration bpm 0.0)
;;               (set_chunk_homophonic_percentage chunk)
;;               chunk))))))


;; (bind-func find_chunk
;;   (lambda (chunk_num gap)
;;     (find_chunk:[CIMChunk*,i64,double,i64,i64]* chunk_num gap 0 100000000)))

;; (bind-func find_chunk
;;   (lambda (chunk_num start)
;;     (find_chunk:[CIMChunk*,i64,double,i64,i64]* chunk_num CIMDefaultGapSize start 100000000)))

;; (bind-func find_chunk
;;   (lambda (chunk_num gap start)
;;     (find_chunk:[CIMChunk*,i64,double,i64,i64]* chunk_num gap start 100000000)))

;; (bind-func find_chunk
;;   (lambda (chunk_num start end)
;;     (find_chunk:[CIMChunk*,i64,double,i64,i64]* chunk_num CIMDefaultGapSize start end)))

;; (bind-func find_chunk
;;   (lambda (chunk_num)
;;     (find_chunk:[CIMChunk*,i64,double,i64,i64]* chunk_num CIMDefaultGapSize 0 100000000)))

;; (bind-func num_chunks
;;   (lambda (gap:double)
;;     (let ((idx 1:i64)
;;           (chunk (find_chunk idx gap)))
;;       (while (cim_chunk_valid chunk)
;;         (set! idx (+ idx 1))
;;         (set! chunk (find_chunk idx gap)))
;;       (- idx 1))))

;; (bind-func num_chunks
;;   (lambda (gap:double startidx endidx)
;;     (let ((idx 1)
;;           (chunk (find_chunk idx gap startidx endidx)))
;;       (while (cim_chunk_valid chunk)
;;         (set! idx (+ idx 1))
;;         (set! chunk (find_chunk idx gap)))
;;       (- idx 1))))

;; ;; a is the lowest index to search from
;; ;; b is the highest index to search too
;; ;;
;; ;; both a and b may be negative meaning index from the end
;; ;; (one trick though is that 0 is start for 'a' and end for 'b')
;; ;;
;; ;; where c is a % of homophonic'ness to look for
;; ;; if c is positive then must be above (abs c) as a %
;; ;; if c is negative then must be below (abs c) as a %
;; ;;
;; ;; d1 is lower bound in beats
;; ;; d2 is the upper bound in beats
;; (bind-func find_random_chunk
;;   (lambda (gap homophonic startidx endidx d1 d2)
;;     (let ((num (num_chunks gap startidx endidx))
;;           (cnt:i64 20)
;;           (chunk (find_chunk (dtoi64 (+ 1.0 (* (i64tod num) (random)))) gap startidx endidx)))
;;       (while (and (or (< (cim_chunk_size chunk) 1)
;;                       (if (< homophonic 0.0)
;;                          (> (cim_chunk_homophonic chunk) (* -1.0 homophonic))
;;                          (< (cim_chunk_homophonic chunk) homophonic))
;;                       (< (* (cim_chunk_duration chunk)
;;                             (/ (cim_chunk_bpm chunk) 60.0))
;;                          d1)
;;                       (> (* (cim_chunk_duration chunk)
;;                             (/ (cim_chunk_bpm chunk) 60.0))
;;                          d2)
;;                       #f)
;;                   (> cnt 0))
;;         (set! chunk null)
;;         (set! cnt (- cnt 1))
;;         (set! chunk (find_chunk (dtoi64 (+ 1.0 (* (i64tod num) (random)))) gap startidx endidx)))
;;       (if (or (< (cim_chunk_size chunk) 1)
;;               (if (< homophonic 0.0)
;;                   (> (cim_chunk_homophonic chunk) (* -1.0 homophonic))
;;                   (< (cim_chunk_homophonic chunk) homophonic))
;;               (< (* (cim_chunk_duration chunk)
;;                     (/ (cim_chunk_bpm chunk) 60.0))
;;                  d1)
;;               (> (* (cim_chunk_duration chunk)
;;                     (/ (cim_chunk_bpm chunk) 60.0))
;;                  d2))
;;           null
;;           chunk))))

;; ;; (bind-func find_random_chunk
;; ;;   (lambda (gap homophonic d1 d2 history)
;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap homophonic
;; ;;                        (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0) (* -1 history)
;; ;;                        d1 d2)))

;; ;; (bind-func find_random_chunk
;; ;;   (lambda (gap homophonic d1 d2)
;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap homophonic
;; ;;                          0 (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0)
;; ;;                          d1 d2)))

;; ;; (bind-func find_random_chunk
;; ;;   (lambda (gap homophonic history)
;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap homophonic
;; ;;                          (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0) (* -1 history)
;; ;;                          0.0 100000.0)))

;; ;; (bind-func find_random_chunk
;; ;;   (lambda (gap homophonic)
;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap homophonic
;; ;;                          0 (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0)
;; ;;                          0.0 100000.0)))

;; ;; (bind-func find_random_chunk
;; ;;   (lambda (gap)
;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap 0.0
;; ;;                          0 (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0)
;; ;;                          0.0 100000.0)))

;; ;; ;; (bind-func find_random_chunk
;; ;; ;;   (lambda (gap homophonic start end d1 d2)
;; ;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap homophonic
;; ;; ;;                          start end
;; ;; ;;                          d1 d2)))

;; ;; (bind-func find_random_chunk
;; ;;   (lambda (gap homophonic start end)
;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap homophonic
;; ;;                          start end
;; ;;                          0.0 100000.0)))

;; ;; (bind-func find_random_chunk
;; ;;   (lambda (gap start end)
;; ;;     (find_random_chunk:[CIMChunk*,double,double,i64,i64,double,double]* gap 0.0
;; ;;                          start end
;; ;;                          0.0 100000.0)))

;; (bind-func dump_chunks
;;   (lambda (gap:double)
;;     (let ((idx 1)
;;           (chunk (find_chunk idx gap)))
;;       (while (cim_chunk_valid chunk)
;;         (println "-----------" idx "------------")
;;         (println chunk)
;;         (set! idx (+ idx 1))
;;         (set! chunk (find_chunk idx gap)))
;;       (println)
;;       void)))

;; (bind-func dump_chunks
;;   (lambda ()
;;     (dump_chunks:[void,double]* CIMDefaultGapSize)))


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ;;
;; ;; CHUNK Database
;; ;;

;; ;; startnote idx,endnot idx,num,size,chunks
;; ;; startnote will be fixed with first insert.
;; ;; endnote will move for every new insert.
;; (bind-type ChunkDB <i64,i64,i64,i64,CIMChunk*>)

;; (bind-func cim_db_setend
;;   (lambda (db:ChunkDB* endidx)
;;     (tset! db 1 endidx)))

;; (bind-func cim_db_end
;;   (lambda (db:ChunkDB*)
;;     (tref db 1)))

;; (bind-func cim_db_size
;;   (lambda (db:ChunkDB*)
;;     (tref db 3)))

;; (bind-func cim_db_num
;;   (lambda (db:ChunkDB*)
;;     (tref db 2)))

;; (bind-func cim_db_increment
;;   (lambda (db)
;;     (tset! db 2 (+ 1 (cim_db_num db)))
;;     (cim_db_num db)))

;; (bind-func cim_db_chunks
;;   (lambda (db:ChunkDB*)
;;     (tref db 4)))

;; (bind-func cim_db_create
;;   (lambda (size)
;;     (let ((chunks (halloc size)))
;;       (ChunkDB 0 0 0 size chunks))))

;; (bind-func cim_db_destroy
;;   (lambda (db:ChunkDB*)
;;     (free (cim_db_chunks:[CIMChunk*,ChunkDB*]* db))
;;     void))

;; (bind-func print:[void,ChunkDB*]*
;;   (lambda (db)
;;     (println "<DB chunks:" (cim_db_num db) ">")
;;     void))

;; ;; copy from db1 into db2
;; (bind-func cim_db_copy
;;   (lambda (db1:ChunkDB* db2:ChunkDB*)
;;     (if (< (cim_db_num db1) (cim_db_size db2))
;;         (let ((chunks1 (cim_db_chunks db1))
;;               (chunks2 (cim_db_chunks db2)))
;;           (doloop (i (cim_db_num db1))
;;             (cim_chunk_copy (pref-ptr chunks1 i)
;;                             (pref-ptr chunks2 i)))
;;           #t)
;;         #f)))

;; ;; expand existing db (in place)
;; (bind-func cim_db_expand
;;   (lambda (db size)
;;     (let ((newsize (+ (cim_db_size db) size))
;;           (chunks1 (cim_db_chunks db))
;;           (chunks2 (halloc newsize)))
;;       (doloop (i size)
;;         (cim_chunk_copy (pref-ptr chunks1 i)
;;                         (pref-ptr chunks2 i)))
;;       (tset! db 3 newsize)
;;       (tset! db 4 chunks2)
;;       (free chunks1)
;;       void)))

;; (bind-func cim_db_next_free_chunk
;;   (lambda (db)
;;     (if (< (cim_db_num db) (cim_db_size db))
;;         (pref-ptr (cim_db_chunks db) (cim_db_num db))
;;         (begin
;;           (cim_db_expand db 100)
;;           (pref-ptr (cim_db_chunks db) (cim_db_num db))))))

;; ;; insert new chunk
;; ;; and return number of chunks in db
;; (bind-func cim_db_insert
;;   (lambda (db:ChunkDB* chunk:CIMChunk*)
;;     (cim_chunk_copy chunk (cim_db_next_free_chunk db))
;;     (cim_db_setend db (cim_chunk_end_index chunk))
;;     (cim_db_increment db)))

;; (bind-func cim_db_find_chunk_a
;;   (lambda (db index)
;;     (if (< index (cim_db_num db))
;;         (pref-ptr (cim_db_chunks db) index)
;;         null)))

;; (bind-func cim_db_find_chunk_b
;;   (lambda (db d1 d2)
;;     (let ((i 0) (d3 0.0) (res null))
;;       (while (< i (cim_db_num db))
;;         (set! d3 (cim_chunk_duration (cim_db_find_chunk_a db i)))
;;         (if (and (> d3 d1) (< d3 d2))
;;             (begin (set! res (cim_db_find_chunk_a db i))
;;                    (set! i 10000000000)))
;;         (set! i (+ i 1)))
;;       res)))

;; (bind-func cim_db_update
;;   (lambda (db gap)
;;     (let ((idx (cim_db_end db)) (i 0)
;;           (lastidx (last_note_index))
;;           (chunk null)
;;           (num (num_chunks gap (+ idx 1) lastidx)))
;;       (dotimes (i num)
;;         (set! chunk (find_chunk num gap (+ idx 1) lastidx))
;;         (if (not (null? chunk))
;;             (cim_db_insert db chunk)))
;;       (cim_db_num db))))

;; (bind-func cim_db_update
;;   (lambda (db)
;;     (cim_db_update:[i64,ChunkDB*,double]* db CIMDefaultGapSize)))

;;;;;;;;;;;;;;;;;;;;;;;;;;; end of mega commented out block  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;; Old version which dealt with recording control change messages ;;;;;
;; (bind-func record_note
;;   (lambda (time type chan:i8 a:i8 b)
;;     (println 'Recording type chan a b)
;;     (if (and (= type MIDI_CC) (<> a 64:i8)) -1  ;; sustain pedal
;;         (let ((note (retrieve_note (aref CIMNoteDurResolver (i8toi64 a)))))
;;           (if (and (not (null? note))
;;                    (<> type MIDI_CC)
;;                    (<> type MIDI_NOTE_ON))
;;               (let ((bpm (cim_note_bpm note))
;;                     (dur (- (/ (i64tod (- time CIMNoteBufferStartTimeI)) CIMSRd) ;;(ftod SRf))
;;                             (cim_note_onset note)))
;;                     (beats (Rat (dtoi64 (* 32.0 dur (/ 60.0 bpm))) 32)))
;;                 (cim_note_set_duration note dur)
;;                 (cim_note_set_beats note beats)
;;                 (aset! CIMNoteDurResolver (i8toi64 a) -1)))
;;           (if (or (= type MIDI_NOTE_ON)
;;                   (= type MIDI_CC)) ;; all CC data is added as negative pitch
;;               (begin
;;                 ;;(if (= CIMNoteBufferIdx 0) (set! CIMNoteBufferStartTimeI time))
;;                 ;;(if (= CIMNoteBufferStartTimeI 0) (set! CIMNoteBufferStartTimeI time))
;;                 (if (= CIMNoteBufferStartTimeI 0) (set_cim_start_time time))
;;                 (let ((note:CIMNote* (aref-ptr CIMNoteBuffer CIMNoteBufferIdx)))
;;                   (tfill! note CIMNoteBufferIdx
;;                           (/ (i64tod (- time CIMNoteBufferStartTimeI)) CIMSRd) ;;(ftod SRf))
;;                           0.0 (i8toi64 (if (= type MIDI_CC) (* -1 a) a)) (i8toi64 b)
;;                           1/1 CIM_GLOBAL_BPM)
;;                   (cim_note_key_set note
;;                                     (cim_key_root CIM_GLOBAL_KEY)
;;                                     (cim_key_major CIM_GLOBAL_KEY))
;;                   (aset! CIMNoteDurResolver (i8toi64 a) CIMNoteBufferIdx)
;;                   (set! CIMNoteBufferIdx (+ CIMNoteBufferIdx 1))
;;                   (update_closures (- CIMNoteBufferIdx 2) (cim_time time))
;;                   (- CIMNoteBufferIdx 1)))
;;               -1)))))


;;;;;;;;;;;; New version which does not record any control change messages ;;;;;;;;;;;;;;;;;
(bind-func record_note
  (lambda (time type chan:i8 a:i8 b)
    ;;(println "Recording: " type chan a b)
    (cond
     ((= type MIDI_CC) -1)  ;; do not record control change messages
     ((= type MIDI_NOTE_OFF)
      (let ((note (retrieve_note (aref CIMNoteDurResolver (i8toi64 a)))))
        (if (not (null? note))
            (let ((bpm (cim_note_bpm note))
                  (dur (- (cim_time time) (cim_note_onset note)))
                  (beats (Rat (dtoi64 (* 32.0 dur (/ 60.0 bpm))) 32)))
              (cim_note_set_duration note dur)
              (cim_note_set_beats note beats)
              (aset! CIMNoteDurResolver (i8toi64 a) -1)
              ;;(println "Resolved note with NOTE_OFF for index " (- CIMNoteBufferIdx 1))
              (- CIMNoteBufferIdx 1)) ;; Resolved open note
            -1))) ;; Unexpected NOTE_OFF
     ((= type MIDI_NOTE_ON)
      (set-forbidden-range-min (get_pitch_history_min))
      (set-forbidden-range-max (get_pitch_history_max))
      (let ((note (retrieve_note (aref CIMNoteDurResolver (i8toi64 a)))))
        (if (not (null? note)) ;; there is already an active note of this pitch - check for zero velocity msg
            (let ((bpm (cim_note_bpm note))
                  (dur (- (cim_time time) (cim_note_onset note)))
                  (beats (Rat (dtoi64 (* 32.0 dur (/ 60.0 bpm))) 32)))
              (cond
               ((= b 0:i8)
                (cim_note_set_duration note dur)
                (cim_note_set_beats note beats)
                (aset! CIMNoteDurResolver (i8toi64 a) -1)
                ;;(println "Resolved note with zero velocity NOTE_ON for index " (- CIMNoteBufferIdx 1))
                (- CIMNoteBufferIdx 1)) ;; Resolved open note (with zero velocity NOTE_ON acting as NOTE_OFF)
               (else ;; Repeated NOTE_ONs without intervening NOTE_OFF - forcibly finish prior note and start a new one
                (cim_note_set_duration note dur)
                (cim_note_set_beats note beats)
                (aset! CIMNoteDurResolver (i8toi64 a) -1) ;; old note is now finished
                (println "Repeated NOTE_ON without NOTE_OFF")
                (record_note time type chan a b) ;; new note added
                )))
            (begin  ;; its a brand new note!
              (if (= CIMNoteBufferStartTimeI 0) (set_cim_start_time time))
              ;;(println "Its a brand new note")
              (set! note (aref-ptr CIMNoteBuffer CIMNoteBufferIdx))
              ;;(println "Adding pitch " (i8toi64 a))
              (set_next_pitch_in_history (i8toi64 a))
              (tfill! note CIMNoteBufferIdx
                      (cim_time time)
                      0.0 (i8toi64 a) (i8toi64 b)
                      1/1 CIM_GLOBAL_BPM)
              ;;(print note)
              (cim_note_key_set note
                                (cim_key_root CIM_GLOBAL_KEY)
                                (cim_key_major CIM_GLOBAL_KEY))
              (aset! CIMNoteDurResolver (i8toi64 a) CIMNoteBufferIdx)
              (set! CIMNoteBufferIdx (+ CIMNoteBufferIdx 1))
              (update_closures (- CIMNoteBufferIdx 2) (cim_time time))
              (- CIMNoteBufferIdx 1)))))
     (else -1))))



(bind-func midi_send_dat
  (lambda (device:PortMidiStream* a:i32 b:i32 c:i32 d:i32)
    (pm_send device a b c d)))


;;;;;;;;;;;;;;;;; second mega commented-out-block ;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ;; where timea and timeb are limits for startime not endtime
;; ;; where variance is a distance 'around' timea and timeb
;; (bind-func note_midi_playback
;;   (lambda (time device:PortMidiStream* channel:i32 startnote:CIMNote* endnote:CIMNote*)
;;     (println "playback -------")
;;     (println "from:" startnote)
;;     (println "to  :" endnote)
;;     (println)
;;     (if (or (null? startnote)
;;             (null? endnote))
;;         void
;;         (let ((startidx (cim_note_index startnote))
;;               (starttime (dtoi64 (* -1.0 CIMSRd (cim_note_onset startnote))))
;;               (endidx (cim_note_index endnote))
;;               (num (+ 1 (- endidx startidx)))
;;               (note null)
;;               ;(pitch 0)
;;               ;(duration 0)
;;               (i 0))
;;           (dotimes (i num)
;;             (set! note (retrieve_note (+ i startidx)))
;;             (begin
;;               (callback (+ time
;;                            (dtoi64 (* CIMSRd (cim_note_onset note)))
;;                            starttime)
;;                         midi_send_dat:[i32,i8*,i32,i32,i32,i32]*
;;                         device
;;                         MIDI_NOTE_ON
;;                         channel
;;                         (i64toi32 (cim_note_pitch note))
;;                         (i64toi32 (cim_note_volume note)))
;;               (callback (+ (dtoi64 (* CIMSRd (cim_note_onset note)))
;;                            (dtoi64 (* CIMSRd (cim_note_duration note)))
;;                            time starttime)
;;                         midi_send_dat:[i32,i8*,i32,i32,i32,i32]*
;;                         device
;;                         MIDI_NOTE_OFF
;;                         channel
;;                         (i64toi32 (cim_note_pitch note))
;;                         0:i32)))
;;           void))))

;; (bind-func note_midi_playback
;;   (lambda (time device:i8* channel chunknum gap:double)
;;     (let ((chunk (find_chunk chunknum gap)))
;;       (note_midi_playback:[void,i64,i8*,i32,CIMNote*,CIMNote*]*
;;        time device channel
;;        (cim_chunk_start chunk)
;;        (cim_chunk_end chunk)))))

;; (bind-func note_midi_playback
;;   (lambda (time device:i8* channel chunknum)
;;     (let ((chunk (find_chunk chunknum CIMDefaultGapSize)))
;;       (note_midi_playback:[void,i64,i8*,i32,CIMNote*,CIMNote*]*
;;        time device channel
;;        (cim_chunk_start chunk)
;;        (cim_chunk_end chunk)))))

;; (bind-func note_midi_playback
;;   (lambda (time device:i8* channel)
;;     (note_midi_playback:[void,i64,i8*,i32,CIMNote*,CIMNote*]*
;;      time device channel
;;      (retrieve_note 0)
;;      (last_note))))
;;
;;;;;;;;;;;;;;;;;;;;;; end second mega commented-out-block ;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; MIDI MESSAGE BUFFER
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; absolute_time seconds idx type chan a b
(bind-type MidiMSG <i64,double,i64,i8,i32,i32,i32>)
(bind-val MidiMSGBuffer |1000000,MidiMSG|)
(bind-val MidiMSGBufferIdx i64 0)
(bind-val MidiMSGBufferStartTime i64 0)

(bind-func cim_save_midi_buffer
  (lambda (filename)
    (let ((fp (fopen filename "w"))
          (idx:i64* (salloc 1)))
      (pset! idx 0 MidiMSGBufferIdx)
      (if (null? fp)
          (begin (println "Failed to open file" (Str filename))
                 -1)
          (let ((data (cast MidiMSGBuffer i8*))
                (pos1 (ptrtoi64 (cast (aref-ptr MidiMSGBuffer 0))))
                (pos2 (ptrtoi64 (cast (aref-ptr MidiMSGBuffer 1))))
                (size (- pos2 pos1)))
            (if (< (fwrite (cast idx i8*) 8 1 fp) 0)
                (begin
                  (fclose fp)
                  (println "Failed to write to " (Str filename))
                  -1)
                (if (< (fwrite data size MidiMSGBufferIdx fp) 0)
                    (begin
                      (fclose fp)
                      (println "Failed to write to " (Str filename))
                      -1)
                    (begin
                      (fclose fp)
                      1))))))))

(bind-func cim_load_midi_buffer
  (lambda (filename)
    (let ((fp (fopen filename "r"))
          (idx:i64* (salloc 1)))
      (if (null? fp)
          (begin (println "Failed to open file" (Str filename))
                 -1)
          (let ((data (cast MidiMSGBuffer i8*))
                (pos1 (ptrtoi64 (cast (aref-ptr MidiMSGBuffer 0))))
                (pos2 (ptrtoi64 (cast (aref-ptr MidiMSGBuffer 1))))
                (size (- pos2 pos1)))
            (if (= (fread (cast idx) 8 1 fp) 8)
                (begin
                  (fclose fp)
                  (println "Failed to load from " (Str filename))
                  -1)
                (if (= (fread data size (pref idx 0) fp) (* size (pref idx 0)))
                    (begin
                      (fclose fp)
                      (println "Failed to load from " (Str filename))
                      -1)
                    (begin
                      (set! MidiMSGBufferIdx (pref idx 0))
                      (fclose fp)
                      1))))))))


(bind-func last_midi_msg
  (lambda ()
    (if (= 0 MidiMSGBufferIdx) null
        (aref-ptr MidiMSGBuffer (- MidiMSGBufferIdx 1)))))

(bind-func midi_msg_buffer_reset
  (lambda ()
    (set! MidiMSGBufferIdx 0)))

(bind-func midi_msg_onset
  (lambda (msg:MidiMSG*)
    (if (null? msg) -1.0
        (tref msg 1))))

(bind-func midi_msg_sampletime
  (lambda (msg:MidiMSG*)
    (if (null? msg) -1
        (tref msg 0))))

(bind-func midi_msg_sample
  (lambda (msg:MidiMSG*)
    (if (null? msg) -1
        (tref msg 0))))

(bind-func midi_msg_idx
  (lambda (msg:MidiMSG*)
    (tref msg 2)))

(bind-func midi_msg_type
  (lambda (msg:MidiMSG*)
    (tref msg 3)))

(bind-func midi_msg_channel
  (lambda (msg:MidiMSG*)
    (tref msg 4)))

(bind-func midi_msg_pitch
  (lambda (msg:MidiMSG*)
    (tref msg 5)))

(bind-func midi_msg_a
  (lambda (msg:MidiMSG*)
    (tref msg 5)))

(bind-func midi_msg_volume
  (lambda (msg:MidiMSG*)
    (tref msg 6)))

(bind-func midi_msg_b
  (lambda (msg:MidiMSG*)
    (tref msg 6)))

(bind-func print:[void,MidiMSG*]*
  (lambda (x)
    (if (null? x)
        (printf "<MIDI: NULL>")
        (printf "<MIDI: idx(%d),time(%f),type(%d),a(%d),b(%d)>" (midi_msg_idx x) (midi_msg_onset x) (midi_msg_type x) (midi_msg_a x) (midi_msg_b x)))
    void))


(bind-func record_midi_msg
  (lambda (time type chan a b)
    (if (= MidiMSGBufferIdx 0) (set! MidiMSGBufferStartTime time))
    (let ((msg:MidiMSG* (aref-ptr MidiMSGBuffer MidiMSGBufferIdx)))
      (tfill! msg time (/ (i64tod (- time MidiMSGBufferStartTime)) CIMSRd) MidiMSGBufferIdx type chan a b)
      ;; (aset! MidiMSGBuffer MidiMSGBufferIdx msg)
      (set! MidiMSGBufferIdx (+ MidiMSGBufferIdx 1))
      (- MidiMSGBufferIdx 1))))

(bind-func retrieve_midi_msg
  (lambda (idx)
    (if (>= idx MidiMSGBufferIdx)
        null
        (aref-ptr MidiMSGBuffer idx))))


(bind-func dump_midi_buffer
  (lambda ()
    (let ((idx 0)
          (msg (retrieve_midi_msg idx)))
      (while (and (not (null? msg))
                  (< idx MidiMSGBufferIdx))
        (println msg)
        (set! idx (+ 1 idx))
        (set! msg (retrieve_midi_msg idx))))))

(bind-func midi_buffer_size
  (lambda ()
    MidiMSGBufferIdx))

(bind-func find_midi_msg
  (lambda (timea timeb)
    (let ((idx 0)
          (msg (retrieve_midi_msg idx)))
      (while (and (not (null? msg))
                  (or (< (midi_msg_onset msg) timea)
                      (> (midi_msg_onset msg) timeb)))
        (set! idx (+ idx 1))
        (set! msg (retrieve_midi_msg idx)))
      msg)))

(bind-func find_midi_msg_off
  (lambda (msgin:MidiMSG*)
    (let ((idx (+ (midi_msg_idx msgin) 1))
          (pitchin (midi_msg_pitch msgin))
          (msg (retrieve_midi_msg idx)))
      (while (or (not (null? msg))
                 (= MIDI_CC (i8toi32 (midi_msg_type msg)))
                 (<> (midi_msg_pitch msg) pitchin))
        (set! idx (+ idx 1))
        (set! msg (retrieve_midi_msg idx)))
      (if (null? msg) msg
          (if (= (i8toi32 (midi_msg_type msg)) MIDI_NOTE_OFF) msg
              (if (= (midi_msg_volume msg) 0)
                  msg
                  null))))))

(bind-func find_midi_msg_dur
  (lambda (msgin:MidiMSG*)
    (let ((idx (+ (midi_msg_idx msgin) 1))
          (pitchin (midi_msg_pitch msgin))
          (msg (retrieve_midi_msg idx)))
      (while (or (not (null? msg))
                 (= MIDI_CC (i8toi32 (midi_msg_type msg)))
                 (<> (midi_msg_pitch msg) pitchin))
        (set! idx (+ idx 1))
        (set! msg (retrieve_midi_msg idx)))
      (if (null? msg) 0.0
          (- (midi_msg_onset msg) (midi_msg_onset msgin))))))


(bind-func midi_send_dat
  (lambda (device:PortMidiStream* a:i32 b:i32 c:i32 d:i32)
    (pm_send device a b c d)))

;; where timea and timeb are limits for startime not endtime
(bind-func midi_playback
  (lambda (time device:i8* timea timeb control_only:i1 force_chan_0:i1)
    (let ((startmsg (find_midi_msg timea (+ timea 0.1)))
          (endmsg (find_midi_msg timeb (+ timeb 0.1))))
      (println startmsg "--" endmsg)
      (if (or (null? startmsg)
              (null? endmsg))
          void
          (let ((startidx (midi_msg_idx startmsg))
                (starttime (* -1 (dtoi64 (* CIMSRd (midi_msg_onset startmsg)))))
                (endidx (midi_msg_idx endmsg))
                (num (- endidx startidx))
                (msg null)
                ;(pitch 0)
                ;(duration 0)
                (i 0))
            (dotimes (i num)
              (set! msg (retrieve_midi_msg (+ i startidx)))
              (if (or (not control_only)
                      (= (i8toi32 (midi_msg_type msg)) MIDI_CC))
                  (callback (+ (dtoi64 (* CIMSRd (midi_msg_onset msg))) time starttime) midi_send_dat:[i32,i8*,i32,i32,i32,i32]*
                            device
                            (i8toi32 (midi_msg_type msg))
                            (if force_chan_0 0:i32 (midi_msg_channel msg))
                            (midi_msg_a msg)
                            (midi_msg_b msg))))
            void)))))


(bind-func midi_playback
  (lambda (time device timea control_only force_chan_0)
    (midi_playback:[void,i64,i8*,double,double,i1,i1]*
     time device timea
     (midi_msg_onset (last_midi_msg))
     control_only force_chan_0)))

(bind-func midi_playback
  (lambda (time device control_only force_chan_0)
    (midi_playback:[void,i64,i8*,double,double,i1,i1]*
     time device
     (midi_msg_onset (retrieve_midi_msg 0))
     (midi_msg_onset (last_midi_msg))
     control_only force_chan_0)))

(bind-func midi_playback
  (lambda (time device control_only)
    (midi_playback:[void,i64,i8*,double,double,i1,i1]*
     time device
     (midi_msg_onset (retrieve_midi_msg 0))
     (midi_msg_onset (last_midi_msg))
     control_only #f)))

(bind-func midi_playback
  (lambda (time device)
    (midi_playback:[void,i64,i8*,double,double,i1,i1]*
     time device
     (midi_msg_onset (retrieve_midi_msg 0))
     (midi_msg_onset (last_midi_msg))
     #f #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; analysis

(bind-val NumRhythmBins i64 24)
(bind-val rhythmbins |24,i64|)

(bind-func release_bpm_bins
  (lambda ()
    (doloop (i NumRhythmBins)
      (aset! rhythmbins i 0))))

(bind-val bpm_low double 72.0)
(bind-val bpm_high double 144.0)
(bind-val bpm_mod double 4.0)

(bind-func print_rhythm_bins
  (lambda ()
    (doloop (i NumRhythmBins)
      (printout (+ (* i (dtoi64 bpm_mod)) (dtoi64 bpm_low)) "[" (aref rhythmbins i) "],"))
    (println)))

(bind-func decrement_bins
  (lambda ()
    (doloop (i NumRhythmBins)
      (if (> (aref rhythmbins i) 0)
          (aset! rhythmbins i (- (aref rhythmbins i) 1))))
    void))

;; (bind-func current_bpm
;;   (let ((useweighting #f)
;;         (firstm 0) (firsti 0) (secondm 0) (secondi 0) (i 0) (idx 0)
;;         (weight 0.0) (bpm 0.0) (firstbpm 0.0) (secondbpm 0.0)
;;         (cur_bpm 120.0))
;;     (lambda ()
;;       (set! firstm 0) (set! firsti 0) (set! secondm 0) (set! secondi i) (set! idx 0)
;;       (dotimes (i NumRhythmBins)
;;         ;;(println "bin" i (aref rhythmbins i))
;;         (if (> (aref rhythmbins i) firstm)
;;             (begin
;;               ;;(println "first" i NumRhythmBins firstm)
;;               (set! secondi firsti)
;;               (set! secondm firstm)
;;               (set! firstm (aref rhythmbins i))
;;               (set! firsti i)
;;               (set! idx i))
;;             (if (> (aref rhythmbins i) secondm)
;;               (begin (set! secondi i)
;;                      (set! secondm (aref rhythmbins i))))))
;;       ;(printout "first: [" firsti "," firstm "] second: [" secondi "," secondm "]\n")
;;       (set! firstbpm (+ bpm_low (* (i64tod firsti) bpm_mod)))
;;       (set! secondbpm (+ bpm_low (* (i64tod secondi) bpm_mod)))
;;       (set! weight (if (= 0 firstm) 1.0 (/ (i64tod secondm) (i64tod firstm))))
;;       ;; use weight
;;       (if useweighting
;;           (set! bpm (+ firstbpm (* weight (- secondbpm firstbpm))))
;;           (set! bpm firstbpm))
;;       ;(printout "bpm:" bpm " bpm1:" firstbpm " bpm2:" secondbpm " "
;;       ;          (* weight (- secondbpm firstbpm)) " weight:" weight "\n")
;;       (if (> firstm 7)
;;           (begin
;;             (dotimes (i NumRhythmBins)
;;               (aset! rhythmbins i 0))
;;             (aset! rhythmbins idx 3)))
;;       (if (and (> (fabs (- cur_bpm bpm)) 2.0)
;;                (> firstm 1))
;;           (begin
;;             (set! CIM_GLOBAL_BPM_CONFIDENCE 0)
;;             ;;(println "changing bpm: " current_bpm " to " bpm)
;;             (set! cur_bpm bpm)
;;             void)
;;           (begin
;;             (set! CIM_GLOBAL_BPM_CONFIDENCE (+ 1 CIM_GLOBAL_BPM_CONFIDENCE))
;;             void))
;;       (if (and (>= CIM_GLOBAL_BPM_CONFIDENCE CIM_GLOBAL_BPM_CONFIDENCE_WEIGHT)
;;                (> (cim_get_pedal 1) 30))
;;           (begin
;;             ;;(println "updating global metro " CIM_GLOBAL_BPM " ... ")
;;             (set! CIM_GLOBAL_BPM cur_bpm)))
;;       ;(print_rhythm_bins)
;;       (dtoi64 CIM_GLOBAL_BPM))))


(bind-func current_bpm
  (lambda ()
    (dtoi64 CIM_GLOBAL_BPM)))


(bind-func bpm_analysis
  (let ((previous_onset 0.0)
        (this_onset 0.0)
        ;; (modr (i64tod 2))
        ;; (low 72.0)
        ;; (high (* low 2.0))
        (modv 0.0)
        (idx 0)
        (bin 0.0))
    (lambda (note:CIMNote*)
      (set! this_onset (cim_note_onset note))
      (if (< this_onset .1)
          (println "Why does this note not have an onset time!: " this_onset))
      (if (and (> (- this_onset previous_onset) .1)
               (< (- this_onset previous_onset) 2.0))
          (begin
            (set! bin (* (/ 1.0 (- this_onset previous_onset)) 60.0))
            (while (or (< bin bpm_low)
                       (>= bin bpm_high))
              (if (< bin bpm_low) (set! bin (* 2.0 bin)))
              (if (>= bin bpm_high) (set! bin (* 0.5 bin))))
            (set! modv (% bin bpm_mod))
            (if (< modv (* 0.5 bpm_mod))
                (set! bin (- bin modv))
                (set! bin (+ bin (- bpm_mod modv))))
            (set! idx (/ (- (dtoi64 bin) (dtoi64 bpm_low)) (dtoi64 bpm_mod)))
            (aset! rhythmbins idx (+ 1 (aref rhythmbins idx)))
            (set! previous_onset this_onset)
            void)
          (begin
            (set! previous_onset this_onset)
            void)))))

(bind-func _qsorti64
  (lambda (dat:i64* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                      (set! tmp (pref dat x))
                      (pset! dat x (pref dat y))
                      (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsorti64 dat left (- index 1))
          (_qsorti64 dat (+ index 1) right))
        void)))

(bind-func sorti64
  (lambda (arr:i64* lgth)
    (_qsorti64 arr 0 (- lgth 1))
    arr))



;; maj 2 2 1 2 2 2 1
;; min 2 1 2 2 1 2 2
;;     2 1 2 2 2 1 2
;;     2 1 2 2 1 2 1

(bind-func weighted_pcs
  (let ((i 0) (j 0)
        (tmppcs:|12,i64|* (alloc))
        (tmpweight:|12,i64|* (alloc)))
    (lambda (pcs:|12,i64|* weighted:|12,i64|*)
      (dotimes (i 12)
        (aset! tmppcs i (aref pcs i)))
      (sorti64 (cast tmppcs i64*) 12)
      (dotimes (i 12)
        (aset! tmpweight i (aref tmppcs (- 11 i))))
      (dotimes (i 12)
        (aset! tmppcs i (aref pcs i)))
      (dotimes (i 12)
        (dotimes (j 12)
          (if (= (aref tmppcs j) (aref tmpweight i))
              (begin
                (aset! weighted i j)
                (aset! tmpweight i -2)
                (aset! tmppcs j -1)))))
      void)))

(bind-func ivls_from_pcs
  (let ((prev -1)
        (i 0) (j 0)
        (total 0)
        (cnt 0))
    (lambda (pcs:|12,i1|* ivls:|12,i64|*)
      (dotimes (i 12)
        (set! cnt 0) (set! total 0) (set! prev -1)
        (aset! ivls i 0)
        (if (aref pcs i)
            (begin
              (set! total (+ total 1))
              (if (> prev -1)
                  (begin (aset! ivls cnt (- i prev))
                         (set! cnt (+ cnt 1))))
              (set! prev i))))
      void)))

;; where guesses are weight ordered pitch classes
(bind-func best_root_match_against_pcs
  (lambda (pcs:|12,i1|* guesses:|12,i64|*)
    (let ((i 0) (pc -1) (lgst 0) (idx 0)
          (results:|12,i64|* (alloc)))
      ;; test best 7 choices
      (dotimes (i 7)
        (aset! results i 0)
        (set! pc (aref guesses i))
        (if (aref pcs (% (+ pc 0) 12)) ;; match yourself of course!
            (aset! results i (+ 5 (aref results i))))
        (if (aref pcs (% (+ pc 7) 12)) ;; match 5th
            (aset! results i (+ 3 (aref results i))))
        (if (and (aref pcs (% (+ pc 3) 12)) ;; match minor 3rd (not major 3rd)
                 (not (aref pcs (% (+ pc 4) 12))))
            (aset! results i (+ 2 (aref results i))))
        (if (and (aref pcs (% (+ pc 4) 12)) ;; match major 3rd (not minor 3rd)
                 (not (aref pcs (% (+ pc 3) 12))))
            (aset! results i (+ 2 (aref results i))))
        (if (and (aref pcs (% (+ pc 4) 12)) ;; if maj + min 3rd subtract
                 (aref pcs (% (+ pc 3) 12)))
            (aset! results i (+ -2 (aref results i))))
        (if (and (aref pcs (% (+ pc 4) 12)) ;; match major 3rd + NOT min 7th
                 (not (aref pcs (% (+ pc 10) 12))))
            (aset! results i (+ 1 (aref results i))))
        (if (and (aref pcs (% (+ pc 8) 12)) ;; match minor 6th (not major 6)
                 (not (aref pcs (% (+ pc 9) 12))))
            (aset! results i (+ 1 (aref results i))))
        (if (and (aref pcs (% (+ pc 9) 12)) ;; match major 6th (not minor 6)
                 (not (aref pcs (% (+ pc 8) 12))))
            (aset! results i (+ 1 (aref results i))))
        (if (and (aref pcs (% (+ pc 8) 12)) ;; if maj + min 6th subtract
                 (aref pcs (% (+ pc 9) 12)))
            (aset! results i (+ -2 (aref results i))))
        (if (and (aref pcs (% (+ pc 10) 12)) ;; if maj 3rd + minor 7th + maj 7th BAD!
                 (aref pcs (% (+ pc 11) 12))
                 (aref pcs (% (+ pc 4) 12)))
            (aset! results i (+ -3 (aref results i))))
        (if (aref pcs (% (+ pc 5) 12))  ;; match 4th
            (aset! results i (+ 1 (aref results i))))
        (if (aref pcs (% (+ pc 6) 12))  ;; negative match augmented 4th dim 5th
            (aset! results i (+ -3 (aref results i))))
        (if (aref pcs (% (+ pc 1) 12)) ;; negative match minor 2nd
            (aset! results i (+ -2 (aref results i))))
        (if (aref pcs (% (+ pc 2) 12)) ;; match 2nd
            (aset! results i (+ 1 (aref results i)))))

      ;; (printout "guesses: ")
      ;; (dotimes (i 7)
      ;;   (printout (aref guesses i) "[" (aref results i) "], ") ;;"\n")
      ;;   (if (> (aref results i) lgst)
      ;;       (begin
      ;;         (set! idx i)
      ;;         (set! lgst (aref results i)))))
      ;; (printout " best> " (aref guesses idx) "  pcs:<")
      ;; (dotimes (i 12)
      ;;   (if (aref pcs i)
      ;;       (printout i ",")))
      ;; (println ">")

      (aref guesses idx))))

;; true for maj
;; false for min
(bind-func best_majmin_guess
  (lambda (pcs:|12,i1|* root:i64)
    (cond ((and (aref pcs (% (+ root 3) 12))
                (not (aref pcs (% (+ root 4) 12))))
           #f) ;; if minor 3rd and NO maj 3rd -> minor
          ((and (aref pcs (% (+ root 4) 12))
                (not (aref pcs (% (+ root 3) 12))))
           #t) ;; if major 3rd and NO min 3rd -> major
          ((and (or (aref pcs (% (+ root 8) 12))
                    (aref pcs (% (+ root 10) 12)))
                (aref pcs (% (+ root 3) 12)))
           #f) ;; if minor 3rd and flat 6 or flat 7 -> minor
          ((and (aref pcs (% (+ root 9) 12))
                (aref pcs (% (+ root 4) 12)))
           #t) ;; if major 3rd and major 6th -> major
          (else #t)))) ;; if in doubt go major

(bind-func total_key_errors
  (lambda (pcs:|12,i1|* root majmin:i1)
    (let ((res 0))
      (if majmin
          (begin ;; major
            (if (aref pcs (% (+ root 1) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 3) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 6) 12)) ;; dim 5 gets extra
                (set! res (+ res 3)))
            (if (aref pcs (% (+ root 8) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 10) 12)) ;; flat 7 - maybe not??
                (set! res (+ res 1))))
          (begin ;; minor
            (if (aref pcs (% (+ root 1) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 4) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 6) 12)) ;; dim 5 gets extra
                (set! res (+ res 3)))
            (if (aref pcs (% (+ root 9) 12))
                (set! res (+ res 1)))))
      ;; (println "root:" root "err:" res)
      (if (and (aref pcs (% (+ root 3) 12))
               (aref pcs (% (+ root 4) 12)))
          (+ res 2)
          res))))

;; where num is the num to set
;; where bit is the bit index to set
;; and where val is either 0 or 1
(bind-func bitset
  (lambda (num:i16 bit:i16 val:i16)
    (^ (& (^ -1:i16 num) (<< 1:i16 bit)) num)))

(bind-func key_analysis
  (let ((ivls:|12,i64|* (alloc))
        (pscnt 0)
        (heaviest_idx:i64 0)
        (pitchset:|12,i1|* (alloc))
        (pitchset_hist:|12,i64|* (alloc))
        (weighted_set:|12,i64|* (alloc))
        (chord:|12,i1|* (alloc))
        (chords:|4096,i64|* (alloc))
        (previous_onset:double 0.0)
        (root 0)
        (majmin #t)
        (idx:i16 0) (i 0) (j 0)
        (pc 0))
    (lambda (note:CIMNote*)
      (set! idx 0)
      (set! pscnt 0)
      (set! heaviest_idx 0)
      ;; first record pitchset stuff
      (set! pc (% (cim_note_pitch note) 12))
      (aset! pitchset_hist pc (+ (aref pitchset_hist pc) 1))
      (aset! pitchset pc #t)
      (weighted_pcs pitchset_hist weighted_set)
      (ivls_from_pcs pitchset ivls)
      ;; next record chord stuff
      (if (< (- (cim_note_onset note) previous_onset) 0.05)
          (begin (aset! chord pc #t) void)
          (begin ;; else marks the end of the last chord
            (dotimes (i 12)
              (if (aref chord i)
                  (set! idx (bitset idx i 1))))
            (aset! chords idx (+ (aref chords idx) 1))
            void))
      (dotimes (j 12)
        (if (> (aref pitchset_hist i) heaviest_idx)
            (set! heaviest_idx j))
        (set! pscnt (+ pscnt (aref pitchset_hist j))))
      (set! previous_onset (cim_note_onset note))
      ;; (println pscnt)
      (if (> pscnt 0)
          (begin
            ;; try a simple root+majmin guess
            (set! root (best_root_match_against_pcs pitchset weighted_set))
            (set! majmin (best_majmin_guess pitchset root))))
      ;; printout
      ;; (printout pscnt " pitchset:")
      ;; (dotimes (i 12)
      ;;   (printout (aref pitchset i) ","))
      ;; (println)
      ;; (printout "pitchsethist:")
      ;; (dotimes (i 12)
      ;;   (printout (aref pitchset_hist i) ","))
      ;; (println)
      ;; (printout "weigthed:")
      ;; (dotimes (i 12)
      ;;   (printout (aref weighted_set i) ","))
      ;; (println)
      ;; printout
      ;;(println "root:" root "maj?:" majmin "errors:" (total_key_errors pitchset root majmin))
      (if (> (aref pitchset_hist heaviest_idx) 8)
          (dotimes (j 12)
            (aset! pitchset_hist j (/ (aref pitchset_hist j) 2))))
      (if (> (total_key_errors pitchset root majmin) 0)
          (begin
            ;; (println "reset")
            (dotimes (i 12)
              (aset! pitchset i #f)
              (aset! pitchset_hist i 0))))
      void)))

(bind-func print_key_bins
  (lambda ()
    (let ((pcs:|12,i64|* (key_analysis.pitchset_hist))
          (i 0))
      (dotimes (i 12)
        (printout (aref pcs i) ","))
      (println "")
      void)))

;; negative numbers for minor
;; positive numbers for major
;; -12 for C minor
(bind-func current_key
  (lambda ()
    (let ((root:i64 (key_analysis.root))
          (majmin:i1 (key_analysis.majmin))
          (pcs:|12,i1|* (key_analysis.pitchset))
          (i 0))
      (tfill! CIM_GLOBAL_KEY root majmin)
      (if majmin
          root
          (if (= root 0) -12
              (* -1 root))))))


;; idx, time, phase, bpm, mass (total volume)
(bind-type CIMTimeSlice <i64,i64,double,double,i64,i64>)
(bind-val CIMTimeSlices |1000000,CIMTimeSlice|)
(bind-val CIMTimeSliceIdx i64 0)

(bind-func cim_tslice_idx
  (lambda (x:CIMTimeSlice*)
    (if (null? x) 0 ;; dangerous!
        (tref x 0))))

;; corresponds to EVENT onset
(bind-func cim_tslice_time
  (lambda (x:CIMTimeSlice*)
    (if (null? x) -1
        (tref x 1))))

;; corresponds to NOTE onset
(bind-func cim_tslice_onset
  (lambda (x:CIMTimeSlice*)
    (tref x 2)))

(bind-func cim_tslice_phase
  (lambda (x:CIMTimeSlice*)
    (tref x 2)))

(bind-func cim_tslice_bpm
  (lambda (x:CIMTimeSlice*)
    (if (null? x) -1
        (tref x 4))))

(bind-func cim_tslice_mass
  (lambda (x:CIMTimeSlice*)
    (tref x 5)))

(bind-func cim_tslice_mass_append
  (lambda (x:CIMTimeSlice* vol:i64)
    (tset! x 5 (+ (tref x 5) vol))))

(bind-func cim_tslice
  (lambda (idx)
    (if (or (< idx 0)
            (> idx CIMTimeSliceIdx))
        null
        (aref-ptr CIMTimeSlices idx))))

(bind-func cim_tslice_last
  (lambda ()
    (aref-ptr CIMTimeSlices CIMTimeSliceIdx)))

(bind-func cim_tslice_add_onset
  (lambda (time onset phase bpm mass)
    (let ((grp (cim_tslice CIMTimeSliceIdx)))
      (tfill! grp CIMTimeSliceIdx time onset phase bpm mass)
      (set! CIMTimeSliceIdx (+ CIMTimeSliceIdx 1))
      grp)))

(bind-func cim_tslice_start_of_bpm
  (lambda (slice)
    (let ((bpm (cim_tslice_bpm slice))
          (idx (cim_tslice_idx slice)))
      (while (= (cim_tslice_bpm slice) bpm)
        (set! idx (- idx 1))
        (set! slice (cim_tslice idx)))
      slice)))

(bind-func cim_tslice_end_of_bpm
  (lambda (slice)
    (let ((bpm (cim_tslice_bpm slice))
          (idx (cim_tslice_idx slice)))
      (while (= (cim_tslice_bpm slice) bpm)
        (set! idx (+ idx 1))
        (set! slice (cim_tslice idx)))
      slice)))

;; search from end
;; if outside err range then return null
;;
;; both time and err in samples
(bind-func find_tslice_closest_time
  (lambda (time:i64 err)
    (let ((idx CIMTimeSliceIdx)
          (slice (cim_tslice idx))
          (slice_high null)
          (t (cim_tslice_time slice))
          (t2:i64 0))
      (while (> t time)
        (set! idx (- idx 1))
        (set! slice (cim_tslice idx))
        (set! t (cim_tslice_time slice)))
      (set! slice_high (cim_tslice (+ idx 1)))
      (set! t2 (cim_tslice_time slice_high))
      (if (< (llabs (- time t2))
             (llabs (- time t)))
          (set! slice slice_high))
      (if (< (llabs (- time (cim_tslice_time slice)))
             err)
          slice
          null))))

(bind-type CIMTimeSliceRange <CIMTimeSlice*,CIMTimeSlice*>)

;; inclusive on low end and high end
(bind-func find_tslice_range
  (let ((range (CIMTimeSliceRange null null)))
    (lambda (t1 t2)
      (let ((idx CIMTimeSliceIdx)
            (slice (cim_tslice idx))
            (slice_high null)
            (slice_low null)
            (t (cim_tslice_time slice)))
        (tfill! range null null)
        (while (> t t2)
          (set! idx (- idx 1))
          (set! slice (cim_tslice idx))
          (set! t (cim_tslice_time slice)))
        (set! slice_high slice)
        (while (>= t t1)
          (set! idx (- idx 1))
          (set! slice (cim_tslice idx))
          (set! t (cim_tslice_time slice)))
        (set! slice_low (cim_tslice (+ idx 1)))
        (tfill! range slice_low slice_high)
        range))))

(bind-func total_tslice_beat_hits
  (lambda (start end beat)
    (let ((bpm (cim_tslice_bpm start))
          (sidx (cim_tslice_idx start))
          (eidx (cim_tslice_idx end))
          (slice null)
          (b (dtoi64 (* beat (/ 60.0 (i64tod bpm)) CIMSRd)))
          (stime (cim_tslice_time start))
          (time 0)
          (cnt 0)
          (tolerance (dtoi64 (* 200.0 (/ 60. (i64tod bpm))))) ;; in samples
          (diff 0)
          (dmod 0)
          (pos 0)
          (i 0))
      (dotimes (i (- eidx (+ sidx 1)))
        (set! slice (cim_tslice (+ 1 sidx i)))
        (set! time (cim_tslice_time slice))
        (set! diff (- time stime))
        (set! dmod (% diff b))
        (if (or (< dmod tolerance)
                (< (- dmod b) tolerance))
            (+ cnt 1)))
      cnt)))

(bind-func record_tslice
  (let ((previous_onset 0.0)
        (this_onset 0.0)
        (bpm 0))
    (lambda (time:i64 note:CIMNote*)
      (set! bpm (current_bpm))
      (set! this_onset (cim_note_onset note))
      ;; if inter-offset less than 1/4 beat at current BPM
      ;; then just add to the mass of the current slice
      (if (< (- this_onset previous_onset) (* 0.25 (/ 60.0 (i64tod bpm))))
          (begin (cim_tslice_mass_append (cim_tslice_last)
                                         (cim_note_volume note))
                 void)
          (begin (cim_tslice_add_onset time this_onset
                                       -1.0 bpm (cim_note_volume note))
                 void))
      (cim_tslice_last))))

;; pulse analysis

(bind-val PhaseTime i64 0)

(bind-func set_phase_time
  (lambda (t)
    (println "Adjusting Phase Time")
    (set! PhaseTime t)))

(bind-func get_phase_time
  (lambda ()
    PhaseTime))

;;  FIX ME !!!!!!!!!!!!!!!
;;  need to fix cases of err, 1/2 and 1/4 being (2 * 1) > 0
;;  i.e. need to fix cases where 1/2,1/4,err get 1 value
;;  before 1/1 even gets started!
(bind-func pulse_analysis
  (let ((bpm (dtoi64 CIM_GLOBAL_BPM))
        (err 0.0)
        (incerr 0)
        (errmax 10)
        (i 0)
        (bucket:|4,i64|* (alloc)))
    (lambda (time)
      ;; (printout "bucket: ")
      ;; (dotimes (i 4)
      ;;   (printout (aref bucket i) ","))
      ;; (println)
      (if (<> (current_bpm) bpm)
          (begin ;; (println "BPM CHANGE" (current_bpm) bpm)
            (set! bpm (current_bpm))
            (set_phase_time time)
            (dotimes (i 4) (aset! bucket i 0))))
      (set! err (% (/ (/ (i64tod (- time PhaseTime)) CIMSRd) (/ 60.0 (i64tod bpm))) 1.0))
      (cond ((or (< err 0.2)
                 (> err 0.8))
             (aset! bucket 0 (+ 1 (aref bucket 0)))
             void)
            ((and (> err 0.4)
                  (< err 0.6))
             (aset! bucket 1 (+ 1 (aref bucket 1)))
             (if (< (* 2 (aref bucket 0))
                    (aref bucket 1))
                 (begin
                   ;; (println "1/2 NOTE CHANGE")
                   (dotimes (i 4) (aset! bucket i 0))
                   (aset! bucket 0 2)
                   (if (and (> (cim_get_pedal 1) 30)
                            (> incerr errmax))
                       (begin
                         (set! incerr 0)
                         (set_phase_time time)))
                   void))
             void)
            ((or (and (> err 0.2)
                     (< err 0.3))
                (and (> err 0.7)
                     (< err 0.8)))
             (aset! bucket 2 (+ 1 (aref bucket 2)))
             (if (< (* 3 (aref bucket 0))
                    (aref bucket 2))
                 (begin
                   ;; (println "1/4 NOTE CHANGE")
                   (dotimes (i 4) (aset! bucket i 0))
                   (aset! bucket 0 2)
                   (if (and (> (cim_get_pedal 1) 30)
                            (> incerr errmax))
                       (begin
                         (set! incerr 0)
                         (set_phase_time time)))
                   void))
             void)
            (else
             (aset! bucket 3 (+ 1 (aref bucket 3)))
             (if (< (* 2 (aref bucket 0))
                    (aref bucket 3))
                 (begin (dotimes (i 4) (aset! bucket i 0))
                        ;; (println "ERR CHANGE")
                        (aset! bucket 0 1)
                        (if (and (> (cim_get_pedal 1) 30)
                                 (> incerr errmax))
                            (begin
                              (set! incerr 0)
                              (set_phase_time time)))
                        void))
             void))
      ;; might not need this but ...
      (if (= (aref bucket 0) 8)
          (begin (dotimes (i 4)
                   (aset! bucket i (/ (aref bucket i) 2)))
                 (aset! bucket 0 4)))
      void)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Basic density analysis
;;

(bind-func density_analysis
  (let ((times:|80,i64|* (alloc))
        (pos:i64 0)
        (cnt 1) (i 0)
        (history 0)
        (lasttime 0)
        (density:double 0.5))
    (lambda (time:i64 time_window:i64)
      (set! lasttime time)
      (aset! times pos time)
      (set! history (- time time_window))
      (set! cnt 0)
      (dotimes (i 80)
        (if (> (aref times i) history)
            (set! cnt (+ cnt 1))))
      (set! density (/ (i64tod cnt) 80.0))
      (set! pos (+ pos 1))
      (if (= pos 80) (set! pos 0))
      void)))

(bind-func current_density
  (lambda ()
    (let ((val:double (density_analysis.density))
          (t:i64 (density_analysis.lasttime)))
      (if (> (- (now) t) CIMSR)
          0.0
          val))))

;;
;; basic velocity analysis
;;
(bind-func velocity_analysis
  (let ((velocities:|30,i64|* (alloc))
        (times:|30,i64|* (alloc))
        (num 0) (avg 0) (avg2 0) (idx 0) (i 0))
    (lambda (time:i64 time_window:i64 note:CIMNote*)
      (aset! velocities idx (cim_note_volume note))
      (aset! times idx time)
      (set! avg2 0) (set! num 0)
      (dotimes (i 30)
        (if (< (- time (aref times i)) time_window)
            (begin
              (set! num (+ num 1))
              (set! avg2 (+ avg2 (aref velocities i))))))
      (set! avg (/ avg2 num))
      (set! idx (+ idx 1))
      (if (>= idx 30)
          (set! idx 0))
      void)))

(bind-func current_avg_velocity:[i64]*
  (lambda ()
    (velocity_analysis.avg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Currently active notes and PCS
;;

(bind-func current_pcs
  (let ((cnt 0) (i 0)
        (pcs:i64* (alloc 12)))
    (lambda ()
      (dotimes (i 12) (pset! pcs i 0))
      (dotimes (i 127)
        (if (> (aref CIMNoteDurResolver i) -1)
            (pset! pcs (% i 12) 1)))
      pcs)))

(bind-func current_pitch_range_low
  (let ((low 0) (i 0))
    (lambda ()
      (set! low 127)
      (dotimes (i 127)
        (if (and (>  (aref CIMNoteDurResolver i) -1)
                 (< i low))
            (set! low i)))
      low)))

(bind-func current_pitch_range_high
  (let ((high 127) (i 0))
    (lambda ()
      (set! high 0)
      (dotimes (i 127)
        (if (and (> (aref CIMNoteDurResolver i) -1)
                 (> i high))
            (set! high i)))
      high)))

(bind-func current_polyphony_cnt
  (let ((cnt 0) (i 0))
    (lambda ()
      (set! cnt 0)
      (dotimes (i 127)
        (if (> (aref CIMNoteDurResolver i) -1)
            (set! cnt (+ cnt 1))))
      cnt)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Analysis
;;
(bind-func analysis
  (lambda (time:i64 note:CIMNote*)
    (if (null? note) void
        (begin
          ;;(println "analysis: >>" note)
          (bpm_analysis note)
          (pulse_analysis time)
          (key_analysis note)
          void))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; write a midi receiver which writes to MSG Buffer and Note Buffer
;;

(bind-val CIM_LOAD_TIME double 0.0)
(bind-val CIM_PRINT_MIDI_MESSAGES i1 1)

(bind-func cim_print_midi_messages
  (lambda (x)
    (set! CIM_PRINT_MIDI_MESSAGES x)))

(bind-func set_lib_load_time
  (lambda ()
    (set! CIM_LOAD_TIME (clock_clock))))

(set_lib_load_time)

;; midi receivers

(bind-func midi_msg_buffer_receiver
  (let ((idx -1)
        (note:CIMNote* null)
        (time_of_first_message 0.0:double)
        (flush_pedal_down:i1 #f))
    (lambda (time:double type:i32 chan:i32 a:i32 b:i32)
      ;;(println "Flush pedal is " flush_pedal_down)
      ;;(println "MIDI message" type chan a b)
      ;; (set! typ (>> (pref msg 0) 4))
      ;; (set! chan (& (pref msg 0) 15))
      ;; (set! a (pref msg 1))
      ;; (set! b (pref msg 2))
      (if (or (= type MIDI_NOTE_ON)
              (= type MIDI_NOTE_OFF)
              (= type MIDI_CC))
          (let ((t1 (now))
                (t2 (dtoi64 (* CIMSRd (- (clock_clock) (audio_clock_base)))))
                (t:i64 t2))
            ;(if CIM_PRINT_MIDI_MESSAGES (println "midi-in" type chan a b))
            (record_midi_msg t (i32toi8 type) chan a b)
            (if (or (= type MIDI_NOTE_ON)
                    (= type MIDI_NOTE_OFF))
                (begin
                  (density_analysis t (dtoi64 (* 2.0 CIMSRd)))
                  (if (not flush_pedal_down)
                      (begin
                        (set! idx (record_note t type (i32toi8 chan) (i32toi8 a) (i32toi8 b)))
                        (cond
                         ((<= 0 idx)
                          ;; (if (= type MIDI_NOTE_ON)
                          ;;     (println "Registered new note into index: " idx)
                          ;;     (println "Resolved note at index: " idx))
                          (set! note (retrieve_note idx))
                          (if (> (cim_get_pedal 1) 30) (analysis t note))
                          (if (not (null? note))
                            (velocity_analysis t (dtoi64 ( 2.0 CIMSRd)) note)))
                       (else (println "Error: record_note function returned -1")))
                       ))))
            (if (= type MIDI_CC)
                (cond
                 ((= a 64:i32)
                       ;; (if (> (cim_get_pedal 2) 30)
                       ;;    (begin
                       ;;       ;;(println "record midi-cc:" a b)
                       ;;       (record_note t type (i32toi8 chan) (i32toi8 a) (i32toi8 b))
                       ;;       void)
                       ;;     void))
                  (pm_send midi_out type chan a b)
                  void)
                 ((= a 66:i32) ;; middle piano pedal
                  (pm_send midi_out type chan a b)
                  void)
                 ((= a 67) ;; left piano pedal
                  (println "Left Pedal: " b)
                  (cond
                   (flush_pedal_down
                    (cond
                     ((< b 64:i32)
                      (set! flush_pedal_down #f) void)
                     (else void)))
                   (else
                    (cond
                     ((> b 64:i32)
                      (note_buffer_reset)
                      (println "Flushing!")
                      (set! flush_pedal_down #t)
                      void)
                     (else
                      (set! flush_pedal_down #f)
                      void)))))
                 ((= a 68)
                  (cim_set_pedal 1 (convert b)) ;; analyse
                  void)
                 ((= a 69)
                  (cim_set_pedal 2 (convert b)) ;; rec
                  void)
                 ((= a 10) ;; 10 and 21 the same
                  (cim_set_pedal 3 (convert b))
                  void)
                 ((= a 7) ;; 10 and 21 the same
                  (cim_set_pedal 3 (convert b)) ;; density 3
                  void)
                 ((= a 21) ;; 10 and 21 the same
                  (cim_set_pedal 3 (convert b))
                  void)
                 ((and (= a 80) ;; CC 80 changes section
                       (> b 60))
                  (next_cim_section)
                  void)
                 ((and (= a 81) ;; CC 81 flush note buffer
                       (> b 60))
                  (note_buffer_reset)
                  void)
                 (else ;; nothing,
                  void)))
            ;;(record_tslice t note)
            void)
          void))))



(bind-func midi_note_on
  (lambda (timestamp:i32 pitch:i32 volume:i32 chan:i32)
    ;;(println "NOTE_ON :" pitch volume chan)
    (midi_msg_buffer_receiver (clock_clock) MIDI_NOTE_ON chan pitch volume)
    void))

(bind-func midi_note_off
  (lambda (timestamp:i32 pitch:i32 volume:i32 chan:i32)
    ;; (println "NOTE_OFF:" pitch volume chan)
    (midi_msg_buffer_receiver (clock_clock) MIDI_NOTE_OFF chan pitch 0)
    void))

(bind-func midi_cc
  (lambda (timestamp:i32 controller:i32 value:i32 chan:i32)
    ;; (println "MIDI_CC :" controller value chan)
    (midi_msg_buffer_receiver (clock_clock) MIDI_CC chan controller value)
    void))

;; by default don't print non note/cc MIDI messages
(bind-func midi_msg
  (lambda (timestamp:i32 type:i32 a:i32 b:i32 chan:i32)
    ;; (println "MIDIMSG: " type a b chan)
    void))


(bind-func midi_note_on
  (lambda (pitch:i32 volume:i32 chan:i32)
    ;;(println "NOTE_ON :" pitch volume chan)
    (midi_msg_buffer_receiver (clock_clock) MIDI_NOTE_ON chan pitch volume)
    void))

(bind-func midi_note_off
  (lambda (pitch:i32 volume:i32 chan:i32)
    ;; (println "NOTE_OFF:" pitch volume chan)
    (midi_msg_buffer_receiver (clock_clock) MIDI_NOTE_OFF chan pitch 0)
    void))

(bind-func midi_cc
  (lambda (controller:i32 value:i32 chan:i32)
    ;; (println "MIDI_CC :" controller value chan)
    (midi_msg_buffer_receiver (clock_clock) MIDI_CC chan controller value)
    void))

;; by default don't print non note/cc MIDI messages
(bind-func midi_msg
  (lambda (type:i32 a:i32 b:i32 chan:i32)
    ;; (println "MIDIMSG: " type a b chan)
    void))


(impc:aot:insert-footer "xtmcimlib")
(define *xtmlib-cimlib-loaded* #t)
