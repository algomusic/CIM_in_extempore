;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; CIM - Controlling Interactive Music
;;
;; Top Level Functions callable from scheme
;; 
;; current_bpm
;; current_key
;; current_density
;; current_avg_velocity
;; current-pcs (a scheme wrapper for current_pcs)
;;
;; cim pedal 1 = analysis
;; cim pedal 2 = record
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load "libs/cimlib.xtm" 'quiet)
(sys:load-preload-check 'cimlib)
(define *xtmlib-cimlib-loaded* #f)

(sys:precomp:suppress-precomp-do
 (sys:load "libs/external/rtmidi.xtm"))
(sys:precomp:insert-sexp '(sys:load "libs/external/rtmidi.xtm"))
(sys:precomp:suppress-precomp-do
 (sys:load "libs/core/math.xtm"))
(sys:precomp:insert-sexp '(sys:load "libs/core/math.xtm"))
;; (sys:precomp:suppress-precomp-do
;;  (sys:load "libs/core/audio_dsp.xtm"))
;; (sys:precomp:insert-sexp '(sys:load "libs/core/audio_dsp.xtm"))
;; (sys:precomp:suppress-precomp-do
;;  (sys:load "libs/core/instruments.xtm"))
;; (sys:precomp:insert-sexp '(sys:load "libs/core/instruments.xtm"))

(sys:precomp:insert-header "xtmcimlib")

(bind-val CIMSRd double 44100.0)
(bind-val CIMSR i64 44100)
;; (bind-val CIMSRd double (integer->real *au:samplerate*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; GLOBALS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-val CIM_GLOBAL_BPM double 120.0)
(bind-val CIM_GLOBAL_BPM_CONFIDENCE i64 0)
(bind-val CIM_GLOBAL_BPM_CONFIDENCE_WEIGHT i64 18)

(bind-func current_bpm_confidence
  (lambda ()
    (clamp (/ (i64tod CIM_GLOBAL_BPM_CONFIDENCE)
              (i64tod CIM_GLOBAL_BPM_CONFIDENCE_WEIGHT))
           0.0 1.0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CONTROLLERS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-val CIM_PEDALS |10,i64|)

(bind-func cim_get_pedal
  (lambda (i:i64)
    (aref CIM_PEDALS i)))

(bind-func cim_set_pedal
  (lambda (i:i64 x:i64)
    (aset! CIM_PEDALS i x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CIMKey
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;;  root (as pc) and major/minor #t/#f
(bind-type CIMKey <i64,i1>)
(bind-val CIM_GLOBAL_KEY CIMKey)

(bind-func cim_key_root
  (lambda (key:CIMKey*)
    (if (null? key) -1
        (tref key 0))))

(bind-func cim_key_major
  (lambda (key:CIMKey*)
    (if (null? key) 0
        (tref key 1))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; NOTE Buffer
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; index (0)
;; seconds-onset (1), seconds-duration (2),
;; pitch (3), volume (4), beats (5), bpm (6), key(7)
(bind-type CIMNote <i64,double,double,i64,i64,Rational,double,CIMKey>)
(bind-val CIMNoteBuffer |1000000,CIMNote|)
(bind-val CIMNoteBufferIdx i64 0)
(bind-val CIMNoteDurResolver |127,i64|)
(bind-val CIMNoteBufferStartTimeI i64 0)
(bind-val CIMNoteBufferStartTimeD double 0.0)

(bind-func cim_save_note_buffer
  (lambda (filename)
    (let ((fp (fopen filename "w"))
          (idx:i64* (salloc 1)))
      (pset! idx 0 CIMNoteBufferIdx)
      (if (null? fp)
          (begin (println "Failed to open file" (Str filename))
                 -1)
          (let ((data (cast CIMNoteBuffer i8*))
                (pos1 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 0))))
                (pos2 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 1))))
                (size (- pos2 pos1)))
            (if (< (fwrite (cast idx i8*) 8 1 fp) 0)
                (begin
                  (fclose fp)
                  (println "Failed to write to " (Str filename))
                  -1)
                (if (< (fwrite data size CIMNoteBufferIdx fp) 0)
                    (begin
                      (fclose fp)
                      (println "Failed to write to " (Str filename))
                      -1)
                    (begin
                      (fclose fp)
                      1))))))))

(bind-func cim_load_note_buffer
  (lambda (filename)
    (let ((fp (fopen filename "r"))
          (idx:i64* (salloc 1)))
      (if (null? fp)
          (begin (println "Failed to open file" (Str filename))
                 -1)
          (let ((data (cast CIMNoteBuffer i8*))
                (pos1 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 0))))
                (pos2 (ptrtoi64 (cast (aref-ptr CIMNoteBuffer 1))))
                (size (- pos2 pos1)))
            (if (= (fread (cast idx) 8 1 fp) 8)
                (begin
                  (fclose fp)
                  (println "Failed to load from " (Str filename))
                  -1)
                (if (= (fread data size (pref idx 0) fp) (* size (pref idx 0)))
                    (begin
                      (fclose fp)
                      (println "Failed to load from " (Str filename))
                      -1)
                    (begin
                      (set! CIMNoteBufferIdx (pref idx 0))
                      (fclose fp)
                      1))))))))

(bind-func init_dur_resolver
  (lambda ()
    (doloop (i 127)
      (aset! CIMNoteDurResolver i -1))
    void))

(init_dur_resolver)

(bind-func cim_note_index
  (lambda (note:CIMNote*)
    (if (null? note) -1
        (tref note 0))))

(bind-func cim_note_onset
  (lambda (note:CIMNote*)
    (if (null? note) -1.0
        (tref note 1))))

(bind-func cim_note_duration
  (lambda (note:CIMNote*)
    (tref note 2)))

(bind-func cim_note_set_duration
  (lambda (note:CIMNote* duration)
    (tset! note 2 duration)))

(bind-func cim_note_pitch
  (lambda (note:CIMNote*)
    (tref note 3)))

(bind-func cim_note_volume
  (lambda (note:CIMNote*)
    (tref note 4)))

(bind-func cim_note_set_beats
  (lambda (note:CIMNote* beats:Rational)
    (tset! note 5 beats)))

(bind-func cim_note_beats
  (lambda (note:CIMNote*)
    (tref note 5)))

(bind-func cim_note_bpm
  (lambda (note:CIMNote*)
    (tref note 6)))

(bind-func cim_note_key
  (lambda (note:CIMNote*)
    (tref-ptr note 7)))

(bind-func cim_note_key_set
  (lambda (note:CIMNote* key majmin)
    (let ((cimkey (tref-ptr note 7)))
      (tset! cimkey 0 key)
      (tset! cimkey 1 majmin)
      note)))

(bind-func CIMNote_print:[void,CIMNote*]*
  (lambda (note)
    (if (null? note)
        (printout "<NOTE: NULL>")
        (printout "<NOTE: " (cim_note_index note)
                  " onset: " (cim_note_onset note)
                  " dur: " (cim_note_duration note)
                  " pitch: " (cim_note_pitch note)
                  " vol: " (cim_note_volume note)
                  " beats: " (cim_note_beats note)
                  " bpm: " (cim_note_bpm note)
                  " key: " (cim_note_key note)
                  ">"))
    void))

(bind-poly print CIMNote_print)

(bind-func retrieve_note
  (lambda (idx)
    (if (or (< idx 0)
            (>= idx CIMNoteBufferIdx))
        null
        (aref-ptr CIMNoteBuffer idx))))

(bind-func last_note
  (lambda ()
    (if (= 0 CIMNoteBufferIdx) null
        (aref-ptr CIMNoteBuffer (- CIMNoteBufferIdx 1)))))

(bind-func note_buffer_reset
  (lambda ()
    ;;(memset (cast CIMNoteBuffer) 0 (* 1000000 40))
    (set! CIMNoteBufferIdx 0)))

(bind-func dump_note_buffer
  (lambda ()
    (doloop (i CIMNoteBufferIdx)
      (println (retrieve_note i)))))

(bind-func find_note_a
  (lambda (timea timeb)
    (let ((idx 0)
          (note (retrieve_note idx)))
      (while (and (not (null? note))
                  (or (< (cim_note_onset note) timea)
                      (> (cim_note_onset note) timeb)))
        (set! idx (+ idx 1))
        (set! note (retrieve_note idx)))
      note)))

(bind-func find_note_b
  (lambda (timea)
    (find_note_a timea timea)))

(bind-func find_note_c
  (lambda (timea pitch)
    (let ((idx 0)
          (note (retrieve_note idx)))
      (while (and (not (null? note))
                  (or (< (cim_note_onset note) timea)
                      (<> (cim_note_pitch note) pitch)))
        (set! idx (+ idx 1))
        (set! note (retrieve_note idx)))
      note)))

(bind-poly find_note find_note_a)
(bind-poly find_note find_note_b)
(bind-poly find_note find_note_c)

;; valid, start note, finish note, size, onset, duration, bpm, homophonic(%)
(bind-type CIMChunk <i1,CIMNote*,CIMNote*,i64,double,double,double,double>)

(bind-func cim_chunk_valid
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) #f
        (tref chunk 0))))

(bind-func cim_chunk_start
  (lambda (chunk:CIMChunk*)
    (tref chunk 1)))

(bind-func cim_chunk_end
  (lambda (chunk:CIMChunk*)
    (tref chunk 2)))

(bind-func cim_chunk_start_index
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0
      (cim_note_index (tref chunk 1)))))

(bind-func cim_chunk_end_index
  (lambda (chunk:CIMChunk*)
    (cim_note_index (tref chunk 2))))

(bind-func cim_chunk_size
  (lambda (chunk:CIMChunk*)
    (if (null? chunk)
        0
        (tref chunk 3))))

(bind-func cim_chunk_onset
  (lambda (chunk:CIMChunk*)
    (if (null? chunk)
        0.0
        (tref chunk 4))))

(bind-func cim_chunk_duration
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0.0
        (tref chunk 5))))

(bind-func cim_chunk_bpm
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0.0
        (tref chunk 6))))

(bind-func cim_chunk_homophonic
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) 0.0
        (tref chunk 7))))

(bind-func cim_chunk_key
  (lambda (chunk:CIMChunk*)
    (if (null? chunk) null
        (cim_note_key (cim_chunk_start chunk)))))

;; percentage of overlapping notes 
(bind-func set_chunk_homophonic_percentage
  (lambda (chunk:CIMChunk*)
    (let ((num (cim_chunk_size chunk))
          (i 0)
          (onset 0.0)
          (duration 0.0)
          (cnt:i64 0)
          (note:CIMNote* null)
          (idx (cim_note_index (cim_chunk_start chunk))))
      (set! cnt 0)
      (set! onset 0.0)
      (set! duration 0.0)
      (dotimes (i idx num)
        (set! note (retrieve_note i))
        (if (and (>= (cim_note_onset note) onset)
                 (< (cim_note_onset note) duration))
            (set! cnt (+ cnt 1)))
        (set! onset (cim_note_onset note))        
        (set! duration (+ onset (* 0.75 (cim_note_duration note)))))
      (tset! chunk 7 (/ (i64tod cnt) (i64tod num)))
      void)))

(bind-func cim_chunk_note_onset
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))    
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (chunkbpm (cim_chunk_bpm chunk))
          (onset (cim_chunk_onset chunk))
          (note (retrieve_note (+ sidx idx))))
      (* (- (cim_note_onset note) onset) (/ chunkbpm 60.0)))))

(bind-func cim_chunk_note_beats
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))    
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (chunkbpm (cim_chunk_bpm chunk))
          (note (retrieve_note (+ sidx idx))))
      (rtod (cim_note_beats note)))))

(bind-func cim_chunk_note_duration
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))    
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))
          (chunkbpm (cim_chunk_bpm chunk))
          (note (retrieve_note (+ sidx idx))))
      (* (cim_note_duration note) (/ chunkbpm 60.0)))))

(bind-func cim_chunk_note_pitch
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))    
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))          
          (note (retrieve_note (+ sidx idx))))
      (cim_note_pitch note))))

(bind-func cim_chunk_note_index
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))    
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))          
          (note (retrieve_note (+ sidx idx))))
      (cim_note_index note))))

(bind-func cim_chunk_note_volume
  (lambda (chunk:CIMChunk* idx)
    (set! idx (% idx (cim_chunk_size chunk)))
    (let ((snote (cim_chunk_start chunk))
          (sidx (cim_note_index snote))          
          (note (retrieve_note (+ sidx idx))))
      (cim_note_volume note))))

(bind-func CIMChunk_print:[void,CIMChunk*]*
  (lambda (chunk)
    (if (null? chunk)
        (printout "<CHUNK: NULL>")
        (begin
          (printout "<CHUNK: valid: " (cim_chunk_valid chunk)) ;; " onset: " (cim_note_onset (cim_chunk_start chunk)))
          (printout "\nstart  : " (cim_note_onset (cim_chunk_start chunk)) " idx: " (cim_note_index (cim_chunk_start chunk)))
          (printout "\nend    : " (cim_note_onset (cim_chunk_end chunk)) " idx: " (cim_note_index (cim_chunk_end chunk)))
          (printout "\nnotes  : " (cim_chunk_size chunk))          
          (printout "\nonset  : " (cim_chunk_onset chunk))
          (printout "\nbpm    : " (cim_chunk_bpm chunk))
          (printout "\nkey    : " (cim_key_root (cim_chunk_key chunk)) " maj? " (cim_key_major (cim_chunk_key chunk)))   
          (printout "\nhomo   : " (dtoi64 (* 100. (cim_chunk_homophonic chunk))) " %")
          (printout "\ndur    : " (cim_chunk_duration chunk) ">")))
    void))

(bind-poly print CIMChunk_print)

(bind-val CIMDefaultGapSize double 3.0)

(bind-func cim_note_closure
  (lambda (a:CIMNote* b:CIMNote* c:CIMNote*)
    (if (or (null? a) (null? b) (null? c)) #f
        (let ((key (cim_note_key a))
              (root (tref key 0))
              (majmin (tref key 1))
              (p1 (cim_note_pitch a))
              (p2 (cim_note_pitch b))
              (p3 (cim_note_pitch c))
              (p312 (% p3 12))
              (i1 (- p2 p1))
              (i2 (- p3 p2))
              (d1 (cim_note_duration a))
              (d2 (cim_note_duration b))
              (d3 (cim_note_duration c))
              (t1 (* (- d3 d2) 5.0)) ;; test1 d3 is longer than d2
              (t2 (if (or (and (> i1 0) (< i2 0))
                          (and (< i1 0) (> i2 0))) ;; test2 change in direction
                      10.0   ;; change in direction
                      0.0))  ;; or not
              (t3 (if (> (* i1 i1) (* i2 i2)) 10.0 0.0)) ;; test3 large to small interval
              (t4 (if (= root p312) 10.0 ;; test4 (finishes on root=10.0 3rd=5.0 5th=5.0)
                      (if (= (% (+ 7 root) 12) p312) 5.0 ;; 7th
                          (if (= (% (+ (if majmin 4 3) root) 12) p312) 5.0 ;; 3rd
                              0.0))))) ;; else 0.0

          (if (> (+ t1 t2 t3 t4) 25.0)
              (println "closure" t1 t2 t3 t4 (+ t1 t2 t3 t4) p1 p2 p3))
          (if (> (+ t1 t2 t3 t4) 25.0)
              #t
              #f)))))
          

;; where startidx is note index to start searching from
;; and endidx is the number of notes to check over
;; if endidx is negative then start from startidx and work backwards
;;
;; if gapsize > 0.0 split based on gapsize
;; if gapsize == 0.0 then split based on elements of closure.
(bind-func find_chunk_a
  (let ((chunk:CIMChunk* (alloc)))
    (lambda (chunk_num:i64 gapsize:double startidx:i64 endidx:i64)
      ;; (println "in find chunk a: " chunk_num)
      (tset! chunk 0 #f)
      (let ((duration 0.0)
            (backward (if (< endidx 0) #t #f))
            (inc (if (< endidx 0) -1 1))
            (startnote (retrieve_note startidx))
            (bpm 120.0)
            (ptime 0.0)
            (finished #f)
            (note (retrieve_note startidx)))
        ;; (println "findchk:")
        ;; (println "startnote: " startnote)
        ;; (println "note: " note)
        ;; (println "KKK")
        (while (and (not (null? note))
                    (not finished))
          (if (if backward
                  (> (- ptime (+ (cim_note_onset note) (cim_note_duration note))) gapsize)
                  (> (- (cim_note_onset note) ptime) gapsize))
              (begin
                (set! chunk_num (- chunk_num 1))
                (if (= chunk_num 0)
                    (begin (set! finished #t)
                           (set! startidx (+ startidx (* -1 inc)))
                           void)
                    (begin (set! startidx (+ startidx 0))
                           (set! startnote note)
                           ;(set! oldnote2 null)
                           ;(set! oldnote1 null)
                           void)))
              (begin
                (set! startidx (+ startidx inc)) void))
          (set! ptime
                (if backward
                    (cim_note_onset note)
                    (+ (cim_note_onset note) (cim_note_duration note))))
          (set! note (retrieve_note startidx)))
        (if (and (null? note) (< chunk_num 2))
            (begin
              (set! finished #t)
              (set! note (last_note))))
        (if (or (not finished) (null? note) (null? startnote))
            null
            (begin
              (set! duration 0.0)
              (set! bpm (cim_note_bpm startnote))
              (set! duration (- (+ (cim_note_onset note)
                                   (cim_note_duration note))
                                (cim_note_onset startnote)))
              (tfill! chunk finished
                      startnote
                      note
                      (+ 1 (- (cim_note_index note) (cim_note_index startnote)))
                      (cim_note_onset startnote)
                      duration bpm 0.0)
              (set_chunk_homophonic_percentage chunk)
              chunk))))))

(bind-func find_chunk_b
  (lambda (chunk_num gap)
    (find_chunk_a chunk_num gap 0 100000000)))

(bind-func find_chunk_c
  (lambda (chunk_num start)
    (find_chunk_a chunk_num CIMDefaultGapSize start 100000000)))

(bind-func find_chunk_d
  (lambda (chunk_num gap start)
    (find_chunk_a chunk_num gap start 100000000)))

(bind-func find_chunk_e
  (lambda (chunk_num start end)
    (find_chunk_a chunk_num CIMDefaultGapSize start end)))

(bind-func find_chunk_f
  (lambda (chunk_num)
    (find_chunk_a chunk_num 1.5 0 100000000)))

(bind-poly find_chunk find_chunk_a)
(bind-poly find_chunk find_chunk_b)
(bind-poly find_chunk find_chunk_c)
(bind-poly find_chunk find_chunk_d)
(bind-poly find_chunk find_chunk_e)
(bind-poly find_chunk find_chunk_f)

(bind-func num_chunks_a
  (lambda (gap)
    (let ((idx 1)
          (chunk (find_chunk idx gap)))
      (while (cim_chunk_valid chunk)
        (set! idx (+ idx 1))
        (set! chunk (find_chunk idx gap)))
      (- idx 1))))

(bind-func num_chunks_b
  (lambda (gap startidx endidx)
    (let ((idx 1)
          (chunk (find_chunk idx gap startidx endidx)))
      (while (cim_chunk_valid chunk)
        (set! idx (+ idx 1))
        (set! chunk (find_chunk idx gap)))
      (- idx 1))))

(bind-poly num_chunks num_chunks_a)
(bind-poly num_chunks num_chunks_b)

;; a is the lowest index to search from
;; b is the highest index to search too
;;
;; both a and b may be negative meaning index from the end
;; (one trick though is that 0 is start for 'a' and end for 'b')
;;
;; where c is a % of homophonic'ness to look for
;; if c is positive then must be above (abs c) as a %
;; if c is negative then must be below (abs c) as a %
;;
;; d1 is lower bound in beats
;; d2 is the upper bound in beats
(bind-func find_random_chunk_a
  (lambda (gap homophonic startidx endidx d1 d2)
    (let ((num (num_chunks_b gap startidx endidx))
          (cnt:i64 20)
          (chunk (find_chunk (dtoi64 (+ 1.0 (* (i64tod num) (random)))) gap startidx endidx)))
      (while (and (or (< (cim_chunk_size chunk) 1)
                      (if (< homophonic 0.0)
                         (> (cim_chunk_homophonic chunk) (* -1.0 homophonic))
                         (< (cim_chunk_homophonic chunk) homophonic))
                      (< (* (cim_chunk_duration chunk)
                            (/ (cim_chunk_bpm chunk) 60.0))
                         d1)
                      (> (* (cim_chunk_duration chunk)
                            (/ (cim_chunk_bpm chunk) 60.0))
                         d2)
                      #f)
                  (> cnt 0))
        (set! chunk null)
        (set! cnt (- cnt 1))
        (set! chunk (find_chunk (dtoi64 (+ 1.0 (* (i64tod num) (random)))) gap startidx endidx)))
      (if (or (< (cim_chunk_size chunk) 1)
              (if (< homophonic 0.0)
                  (> (cim_chunk_homophonic chunk) (* -1.0 homophonic))
                  (< (cim_chunk_homophonic chunk) homophonic))
              (< (* (cim_chunk_duration chunk)
                    (/ (cim_chunk_bpm chunk) 60.0))
                 d1)
              (> (* (cim_chunk_duration chunk)
                    (/ (cim_chunk_bpm chunk) 60.0))
                 d2))
          null       
          chunk))))

(bind-func find_random_chunk_b
  (lambda (gap homophonic d1 d2 history)
    (find_random_chunk_a gap homophonic
                         (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0) (* -1 history)
                         d1 d2)))

(bind-func find_random_chunk_c
  (lambda (gap homophonic d1 d2)
    (find_random_chunk_a gap homophonic
                         0 (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0)                         
                         d1 d2)))

(bind-func find_random_chunk_d
  (lambda (gap homophonic history)
    (find_random_chunk_a gap homophonic
                         (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0) (* -1 history)
                         0.0 100000.0)))

(bind-func find_random_chunk_e
  (lambda (gap homophonic)
    (find_random_chunk_a gap homophonic
                         0 (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0)
                         0.0 100000.0)))

(bind-func find_random_chunk_f
  (lambda (gap)
    (find_random_chunk_a gap 0.0
                         0 (if (> CIMNoteBufferIdx 0) (- CIMNoteBufferIdx 1) 0)
                         0.0 100000.0)))

(bind-func find_random_chunk_g
  (lambda (gap homophonic start end d1 d2)
    (find_random_chunk_a gap homophonic
                         start end
                         d1 d2)))

(bind-func find_random_chunk_h
  (lambda (gap homophonic start end)
    (find_random_chunk_a gap homophonic
                         start end
                         0.0 100000.0)))

(bind-func find_random_chunk_i
  (lambda (gap start end)
    (find_random_chunk_a gap 0.0
                         start end
                         0.0 100000.0)))

(bind-poly find_random_chunk find_random_chunk_a)
(bind-poly find_random_chunk find_random_chunk_b)
(bind-poly find_random_chunk find_random_chunk_c)
(bind-poly find_random_chunk find_random_chunk_d)
(bind-poly find_random_chunk find_random_chunk_e)
(bind-poly find_random_chunk find_random_chunk_f)

(bind-func dump_chunks_a
  (lambda (gap:double)
    (let ((idx 1)
          (chunk (find_chunk idx gap)))
      (while (cim_chunk_valid chunk)
        (println "-----------" idx "------------")
        (println chunk)
        (set! idx (+ idx 1))
        (set! chunk (find_chunk idx gap)))
      (println)
      void)))

(bind-func dump_chunks_b
  (lambda ()
    (dump_chunks_a CIMDefaultGapSize)))

(bind-poly dump_chunks dump_chunks_a)
(bind-poly dump_chunks dump_chunks_b)

(bind-func record_note
  (lambda (time type chan:i8 a b)
    (if (and (= type MIDI_CC) (<> a 64)) -1  ;; sustain pedal
        (let ((note (retrieve_note (aref CIMNoteDurResolver (i8toi64 a)))))
          (if (and (not (null? note))
                   (<> type MIDI_CC)
                   (<> type MIDI_NOTE_ON))
              (let ((bpm (cim_note_bpm note))
                    (dur (- (/ (i64tod (- time CIMNoteBufferStartTimeI)) CIMSRd) ;;(ftod SRf))
                            (cim_note_onset note)))
                    (beats (Rat (dtoi64 (* 32.0 dur (/ 60.0 bpm))) 32)))
                (cim_note_set_duration note dur)
                (cim_note_set_beats note beats)
                (aset! CIMNoteDurResolver (i8toi64 a) -1)))
          (if (or (= type MIDI_NOTE_ON)
                  (= type MIDI_CC)) ;; all CC data is added as negative pitch
              (begin
                ;;(if (= CIMNoteBufferIdx 0) (set! CIMNoteBufferStartTimeI time))
                (if (= CIMNoteBufferStartTimeI 0) (set! CIMNoteBufferStartTimeI time))
                (let ((note:CIMNote* (aref-ptr CIMNoteBuffer CIMNoteBufferIdx)))
                  (tfill! note CIMNoteBufferIdx
                          (/ (i64tod (- time CIMNoteBufferStartTimeI)) CIMSRd) ;;(ftod SRf))
                          0.0 (i8toi64 (if (= type MIDI_CC) (* -1 a) a)) (i8toi64 b)
                          1/1 CIM_GLOBAL_BPM)
                  (cim_note_key_set note
                                    (cim_key_root CIM_GLOBAL_KEY)
                                    (cim_key_major CIM_GLOBAL_KEY))
                  (aset! CIMNoteDurResolver (i8toi64 a) CIMNoteBufferIdx)
                  (set! CIMNoteBufferIdx (+ CIMNoteBufferIdx 1))
                  (- CIMNoteBufferIdx 1)))
              -1)))))


(bind-func midi_send_dat
  (lambda (device:i8* a:i8 b:i8 c:i8 d:i8)
    (midi_send (cast device) a b c d)))

;; where timea and timeb are limits for startime not endtime
;; where variance is a distance 'around' timea and timeb
(bind-func note_midi_playback_a
  (lambda (time device:i8* channel startnote:CIMNote* endnote:CIMNote*)
    (println "playback -------")
    (println "from:" startnote)
    (println "to  :" endnote)
    (println)
    (if (or (null? startnote)
            (null? endnote))
        void
        (let ((startidx (cim_note_index startnote))
              (starttime (dtoi64 (* -1.0 CIMSRd (cim_note_onset startnote))))
              (endidx (cim_note_index endnote))
              (num (+ 1 (- endidx startidx)))
              (note null)
              (pitch 0)
              (duration 0)
              (i 0))
          (dotimes (i num)              
            (set! note (retrieve_note (+ i startidx)))
            (begin
              (callback (+ time
                           (dtoi64 (* CIMSRd (cim_note_onset note)))
                           starttime)
                        midi_send_dat
                        device
                        MIDI_NOTE_ON channel
                        (i64toi8 (cim_note_pitch note))
                        (i64toi8 (cim_note_volume note)))
              (callback (+ (dtoi64 (* CIMSRd (cim_note_onset note)))
                           (dtoi64 (* CIMSRd (cim_note_duration note)))
                           time starttime)
                        midi_send_dat
                        device
                        MIDI_NOTE_OFF channel
                        (i64toi8 (cim_note_pitch note))
                        (i64toi8 0))))
          void))))

(bind-func note_midi_playback_b
  (lambda (time device:i8* channel chunknum gap)
    (let ((chunk (find_chunk chunknum gap)))
      (note_midi_playback_a time device channel
                            (cim_chunk_start chunk)
                            (cim_chunk_end chunk)))))

(bind-func note_midi_playback_c
  (lambda (time device:i8* channel chunknum)
    (let ((chunk (find_chunk chunknum 2.0)))
      (note_midi_playback_a time device channel
                            (cim_chunk_start chunk)
                            (cim_chunk_end chunk)))))

(bind-func note_midi_playback_d
  (lambda (time device:i8* channel)
    (note_midi_playback_a time device channel
                          (retrieve_note 0)
                          (last_note))))

(bind-poly note_midi_playback note_midi_playback_a)
(bind-poly note_midi_playback note_midi_playback_b)
(bind-poly note_midi_playback note_midi_playback_c)
(bind-poly note_midi_playback note_midi_playback_d)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; MIDI MESSAGE BUFFER
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; absolute_time seconds idx type chan a b
(bind-type MidiMSG <i64,double,i64,i8,i32,i32,i32>)
(bind-val MidiMSGBuffer |1000000,MidiMSG|)
(bind-val MidiMSGBufferIdx i64 0)
(bind-val MidiMSGBufferStartTime i64 0)

(bind-func last_midi_msg
  (lambda ()
    (if (= 0 MidiMSGBufferIdx) null
        (aref-ptr MidiMSGBuffer (- MidiMSGBufferIdx 1)))))

(bind-func midi_msg_buffer_reset
  (lambda ()
    (set! MidiMSGBufferIdx 0)))

(bind-func midi_msg_onset
  (lambda (msg:MidiMSG*)
    (if (null? msg) -1.0
        (tref msg 1))))

(bind-func midi_msg_sampletime
  (lambda (msg:MidiMSG*)
    (if (null? msg) -1
        (tref msg 0))))

(bind-func midi_msg_sample
  (lambda (msg:MidiMSG*)
    (if (null? msg) -1
        (tref msg 0))))

(bind-func midi_msg_idx
  (lambda (msg:MidiMSG*)
    (tref msg 2)))

(bind-func midi_msg_type
  (lambda (msg:MidiMSG*)
    (tref msg 3)))

(bind-func midi_msg_channel
  (lambda (msg:MidiMSG*)
    (tref msg 4)))

(bind-func midi_msg_pitch
  (lambda (msg:MidiMSG*)
    (tref msg 5)))

(bind-func midi_msg_a
  (lambda (msg:MidiMSG*)
    (tref msg 5)))

(bind-func midi_msg_volume
  (lambda (msg:MidiMSG*)
    (tref msg 6)))

(bind-func midi_msg_b
  (lambda (msg:MidiMSG*)
    (tref msg 6)))

(bind-func MidiMSG_print:[void,MidiMSG*]*
  (lambda (x)
    (if (null? x)
        (printf "<MIDI: NULL>")
        (printf "<MIDI: idx(%d),time(%f),type(%d),a(%d),b(%d)>" (midi_msg_idx x) (midi_msg_onset x) (midi_msg_type x) (midi_msg_a x) (midi_msg_b x)))
    void))

(bind-poly print MidiMSG_print)

(bind-func record_midi_msg
  (lambda (time type chan a b)
    (if (= MidiMSGBufferIdx 0) (set! MidiMSGBufferStartTime time))
    (let ((msg:MidiMSG* (aref-ptr MidiMSGBuffer MidiMSGBufferIdx)))
      (tfill! msg time (/ (i64tod (- time MidiMSGBufferStartTime)) CIMSRd) MidiMSGBufferIdx type chan a b)
      ;; (aset! MidiMSGBuffer MidiMSGBufferIdx msg)
      (set! MidiMSGBufferIdx (+ MidiMSGBufferIdx 1))
      (- MidiMSGBufferIdx 1))))

(bind-func retrieve_midi_msg_a
  (lambda (idx)
    (if (>= idx MidiMSGBufferIdx)
        null
        (aref-ptr MidiMSGBuffer idx))))

(bind-poly retrieve_midi_msg retrieve_midi_msg_a)

(bind-func dump_midi_buffer
  (lambda ()
    (let ((idx 0)
          (msg (retrieve_midi_msg idx)))
      (while (and (not (null? msg))
                  (< idx MidiMSGBufferIdx))
        (println msg)
        (set! idx (+ 1 idx))
        (set! msg (retrieve_midi_msg idx))))))

(bind-func midi_buffer_size
  (lambda ()
    MidiMSGBufferIdx))

(bind-func find_midi_msg_a
  (lambda (timea timeb)
    (let ((idx 0)
          (msg (retrieve_midi_msg idx)))
      (while (and (not (null? msg))
                  (or (< (midi_msg_onset msg) timea)
                      (> (midi_msg_onset msg) timeb)))
        (set! idx (+ idx 1))
        (set! msg (retrieve_midi_msg idx)))
      msg)))

(bind-poly find_midi_msg find_midi_msg_a)

(bind-func find_midi_msg_off
  (lambda (msgin:MidiMSG*)
    (let ((idx (+ (midi_msg_idx msgin) 1))
          (pitchin (midi_msg_pitch msgin))
          (msg (retrieve_midi_msg idx)))
      (while (or (not (null? msg))
                 (= MIDI_CC (midi_msg_type msg))
                 (<> (midi_msg_pitch msg) pitchin))
        (set! idx (+ idx 1))
        (set! msg (retrieve_midi_msg idx)))
      (if (null? msg) msg
          (if (= (midi_msg_type msg) MIDI_NOTE_OFF) msg
              (if (= (midi_msg_volume msg) 0)
                  msg
                  null))))))

(bind-func find_midi_msg_dur
  (lambda (msgin:MidiMSG*)
    (let ((idx (+ (midi_msg_idx msgin) 1))
          (pitchin (midi_msg_pitch msgin))
          (msg (retrieve_midi_msg idx)))
      (while (or (not (null? msg))
                 (= MIDI_CC (midi_msg_type msg))
                 (<> (midi_msg_pitch msg) pitchin))
        (set! idx (+ idx 1))
        (set! msg (retrieve_midi_msg idx)))
      (if (null? msg) 0.0
          (- (midi_msg_onset msg) (midi_msg_onset msgin))))))


(bind-func midi_send_dat
  (lambda (device:i8* a:i8 b:i8 c:i8 d:i8)
    (midi_send (cast device) a b c d)))

;; where timea and timeb are limits for startime not endtime
(bind-func midi_playback_a
  (lambda (time device:i8* timea timeb control_only:i1)
    (let ((startmsg (find_midi_msg timea (+ timea 0.1)))
          (endmsg (find_midi_msg timeb (+ timeb 0.1))))
      (println startmsg "--" endmsg)
      (if (or (null? startmsg)
              (null? endmsg))
          void
          (let ((startidx (midi_msg_idx startmsg))
                (starttime (* -1 (dtoi64 (* CIMSRd (midi_msg_onset startmsg)))))
                (endidx (midi_msg_idx endmsg))
                (num (- endidx startidx))
                (msg null)
                (pitch 0)
                (duration 0)
                (i 0))
            (dotimes (i num)              
              (set! msg (retrieve_midi_msg (+ i startidx)))
              (if (or (not control_only)
                      (= (midi_msg_type msg) MIDI_CC))
                  (callback (+ (dtoi64 (* CIMSRd (midi_msg_onset msg))) time starttime) midi_send_dat
                            device
                            (midi_msg_type msg)
                            (i32toi8 (midi_msg_channel msg))
                            (i32toi8 (midi_msg_a msg))
                            (i32toi8(midi_msg_b msg)))))
            void)))))

(bind-func midi_playback_b
  (lambda (time device timea control_only)
    (midi_playback_a time device timea
                     (midi_msg_onset (last_midi_msg))
                     control_only)))

(bind-func midi_playback_c
  (lambda (time device control_only)
    (midi_playback_a time device
                     (midi_msg_onset (retrieve_midi_msg 0))
                     (midi_msg_onset (last_midi_msg))
                     control_only)))

(bind-func midi_playback_d
  (lambda (time device)
    (midi_playback_a time device
                     (midi_msg_onset (retrieve_midi_msg 0))
                     (midi_msg_onset (last_midi_msg))
                     #f)))

(bind-poly midi_playback midi_playback_a)
(bind-poly midi_playback midi_playback_b)
(bind-poly midi_playback midi_playback_c)
(bind-poly midi_playback midi_playback_d)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; analysis

(bind-val NumRhythmBins i64 24)
(bind-val rhythmbins |24,i64|)

(bind-func release_bpm_bins
  (lambda ()
    (doloop (i NumRhythmBins)
      (aset! rhythmbins i 0))))

(bind-val bpm_low double 72.0)
(bind-val bpm_high double 144.0)
(bind-val bpm_mod double 4.0)

(bind-func print_rhythm_bins
  (lambda ()
    (doloop (i NumRhythmBins)
      (printout (+ (* i (dtoi64 bpm_mod)) (dtoi64 bpm_low)) "[" (aref rhythmbins i) "],"))
    (println)))

(bind-func decrement_bins
  (lambda ()
    (doloop (i NumRhythmBins)
      (if (> (aref rhythmbins i) 0)
          (aset! rhythmbins i (- (aref rhythmbins i) 1))))
    void))

(bind-func current_bpm
  (let ((useweighting #f)
        (firstm 0) (firsti 0) (secondm 0) (secondi 0) (i 0) (idx 0)
        (weight 0.0) (bpm 0.0) (firstbpm 0.0) (secondbpm 0.0)
        (current_bpm 120.0))
    (lambda ()
      (set! firstm 0) (set! firsti 0) (set! secondm 0) (set! secondi i) (set! idx 0)
      (dotimes (i NumRhythmBins)
        (if (> (aref rhythmbins i) secondm)
            (begin (set! secondi i)
                   (set! secondm (aref rhythmbins i))))
        (if (> (aref rhythmbins i) firstm)
            (begin
              (set! secondi firsti)
              (set! secondm firstm)              
              (set! firstm (aref rhythmbins i))
              (set! firsti i)
              (set! idx i))))
      ;;(printout "first: [" firsti "," firstm "] second: [" secondi "," secondm "]\n")      
      (set! firstbpm (+ bpm_low (* (i64tod firsti) bpm_mod)))
      (set! secondbpm (+ bpm_low (* (i64tod secondi) bpm_mod)))
      (set! weight (if (= 0 firstm) 1.0 (/ (i64tod secondm) (i64tod firstm))))
      ;; use weight
      (if useweighting
          (set! bpm (+ firstbpm (* weight (- secondbpm firstbpm))))
          (set! bpm firstbpm))
      ;(printout "bpm:" bpm " bpm1:" firstbpm " bpm2:" secondbpm " "
      ;          (* weight (- secondbpm firstbpm)) " weight:" weight "\n")
      (if (> firstm 7)
          (begin
            (dotimes (i NumRhythmBins)
              (aset! rhythmbins i 0))
            (aset! rhythmbins idx 3)))
      (if (> (fabs (- current_bpm bpm)) 2.0)
          (begin
            (set! CIM_GLOBAL_BPM_CONFIDENCE 0)
            ;;(println "changing bpm: " current_bpm " to " bpm)
            (set! current_bpm bpm)
            void)
          (begin
            (set! CIM_GLOBAL_BPM_CONFIDENCE (+ 1 CIM_GLOBAL_BPM_CONFIDENCE))
            void))
      (if (and (>= CIM_GLOBAL_BPM_CONFIDENCE CIM_GLOBAL_BPM_CONFIDENCE_WEIGHT)
               (> (cim_get_pedal 1) 30))
          (begin
            ;;(println "updating global metro " CIM_GLOBAL_BPM " ... ")
            (set! CIM_GLOBAL_BPM current_bpm)))
      ;;(print_rhythm_bins)
      (dtoi64 CIM_GLOBAL_BPM))))

(bind-func bpm_analysis
  (let ((previous_onset 0.0)
        (this_onset 0.0)
        ;; (modr (i64tod 2))
        ;; (low 72.0)
        ;; (high (* low 2.0))
        (modv 0.0)
        (idx 0)
        (bin 0.0))
    (lambda (note:CIMNote*)
      (set! this_onset (cim_note_onset note))
      (if (< this_onset .1)
          (println "Why does this note not have an onset time!: " this_onset))
      (if (and (> (- this_onset previous_onset) .1)
               (< (- this_onset previous_onset) 2.0))
          (begin
            (set! bin (* (/ 1.0 (- this_onset previous_onset)) 60.0))
            (while (or (< bin bpm_low)
                       (>= bin bpm_high))
              (if (< bin bpm_low) (set! bin (* 2.0 bin)))
              (if (>= bin bpm_high) (set! bin (* 0.5 bin))))
            (set! modv (% bin bpm_mod))
            (if (< modv (* 0.5 bpm_mod))
                (set! bin (- bin modv))
                (set! bin (+ bin (- bpm_mod modv))))
            (set! idx (/ (- (dtoi64 bin) (dtoi64 bpm_low)) (dtoi64 bpm_mod)))
            (aset! rhythmbins idx (+ 1 (aref rhythmbins idx)))
            (set! previous_onset this_onset)
            void)
          (begin
            (set! previous_onset this_onset)
            void)))))

;; maj 2 2 1 2 2 2 1
;; min 2 1 2 2 1 2 2
;;     2 1 2 2 2 1 2
;;     2 1 2 2 1 2 1

(bind-func weighted_pcs
  (let ((i 0) (j 0)
        (tmppcs:|12,i64|* (alloc))
        (tmpweight:|12,i64|* (alloc)))
    (lambda (pcs:|12,i64|* weighted:|12,i64|*)
      (dotimes (i 12)
        (aset! tmppcs i (aref pcs i)))
      (sort (cast tmppcs i64*) 12)
      (dotimes (i 12)
        (aset! tmpweight i (aref tmppcs (- 11 i))))
      (dotimes (i 12)
        (aset! tmppcs i (aref pcs i)))
      (dotimes (i 12)
        (dotimes (j 12)
          (if (= (aref tmppcs j) (aref tmpweight i))
              (begin
                (aset! weighted i j)
                (aset! tmpweight i -2)
                (aset! tmppcs j -1)))))
      void)))

(bind-func ivls_from_pcs
  (let ((prev -1)
        (i 0) (j 0)
        (total 0)
        (cnt 0))
    (lambda (pcs:|12,i1|* ivls:|12,i64|*)
      (dotimes (i 12)
        (set! cnt 0) (set! total 0) (set! prev -1)
        (aset! ivls i 0)
        (if (aref pcs i)
            (begin
              (set! total (+ total 1))
              (if (> prev -1)
                  (begin (aset! ivls cnt (- i prev))
                         (set! cnt (+ cnt 1))))
              (set! prev i))))
      void)))

;; where guesses are weight ordered pitch classes
(bind-func best_root_match_against_pcs
  (lambda (pcs:|12,i1|* guesses:|12,i64|*)
    (let ((i 0) (pc -1) (lgst 0) (idx 0)
          (results:|12,i64|* (alloc)))
      ;; test best 7 choices
      (dotimes (i 7)
        (aset! results i 0)
        (set! pc (aref guesses i))
        (if (aref pcs (% (+ pc 0) 12)) ;; match yourself of course!
            (aset! results i (+ 5 (aref results i))))
        (if (aref pcs (% (+ pc 7) 12)) ;; match 5th
            (aset! results i (+ 3 (aref results i))))
        (if (and (aref pcs (% (+ pc 3) 12)) ;; match minor 3rd (not major 3rd)
                 (not (aref pcs (% (+ pc 4) 12))))
            (aset! results i (+ 2 (aref results i))))
        (if (and (aref pcs (% (+ pc 4) 12)) ;; match major 3rd (not minor 3rd)
                 (not (aref pcs (% (+ pc 3) 12))))
            (aset! results i (+ 2 (aref results i))))
        (if (and (aref pcs (% (+ pc 4) 12)) ;; if maj + min 3rd subtract
                 (aref pcs (% (+ pc 3) 12)))
            (aset! results i (+ -2 (aref results i)))) 
        (if (and (aref pcs (% (+ pc 4) 12)) ;; match major 3rd + NOT min 7th
                 (not (aref pcs (% (+ pc 10) 12))))
            (aset! results i (+ 1 (aref results i))))
        (if (and (aref pcs (% (+ pc 8) 12)) ;; match minor 6th (not major 6)
                 (not (aref pcs (% (+ pc 9) 12))))
            (aset! results i (+ 1 (aref results i))))
        (if (and (aref pcs (% (+ pc 9) 12)) ;; match major 6th (not minor 6)
                 (not (aref pcs (% (+ pc 8) 12))))
            (aset! results i (+ 1 (aref results i))))
        (if (and (aref pcs (% (+ pc 8) 12)) ;; if maj + min 6th subtract
                 (aref pcs (% (+ pc 9) 12)))
            (aset! results i (+ -2 (aref results i))))
        (if (and (aref pcs (% (+ pc 10) 12)) ;; if maj 3rd + minor 7th + maj 7th BAD!
                 (aref pcs (% (+ pc 11) 12))
                 (aref pcs (% (+ pc 4) 12)))
            (aset! results i (+ -3 (aref results i))))
        (if (aref pcs (% (+ pc 5) 12))  ;; match 4th
            (aset! results i (+ 1 (aref results i))))
        (if (aref pcs (% (+ pc 6) 12))  ;; negative match augmented 4th dim 5th
            (aset! results i (+ -3 (aref results i))))
        (if (aref pcs (% (+ pc 1) 12)) ;; negative match minor 2nd
            (aset! results i (+ -2 (aref results i))))
        (if (aref pcs (% (+ pc 2) 12)) ;; match 2nd
            (aset! results i (+ 1 (aref results i)))))
      
      ;; (printout "guesses: ")
      ;; (dotimes (i 7)
      ;;   (printout (aref guesses i) "[" (aref results i) "], ") ;;"\n")
      ;;   (if (> (aref results i) lgst)
      ;;       (begin
      ;;         (set! idx i)
      ;;         (set! lgst (aref results i)))))
      ;; (printout " best> " (aref guesses idx) "  pcs:<")
      ;; (dotimes (i 12)
      ;;   (if (aref pcs i)
      ;;       (printout i ",")))
      ;; (println ">")
      
      (aref guesses idx))))

;; true for maj
;; false for min
(bind-func best_majmin_guess
  (lambda (pcs:|12,i1|* root:i64)
    (cond ((and (aref pcs (% (+ root 3) 12))
                (not (aref pcs (% (+ root 4) 12))))
           #f) ;; if minor 3rd and NO maj 3rd -> minor
          ((and (aref pcs (% (+ root 4) 12))
                (not (aref pcs (% (+ root 3) 12))))
           #t) ;; if major 3rd and NO min 3rd -> major
          ((and (or (aref pcs (% (+ root 8) 12))
                    (aref pcs (% (+ root 10) 12)))
                (aref pcs (% (+ root 3) 12)))
           #f) ;; if minor 3rd and flat 6 or flat 7 -> minor 
          ((and (aref pcs (% (+ root 9) 12))
                (aref pcs (% (+ root 4) 12)))
           #t) ;; if major 3rd and major 6th -> major
          (else #t)))) ;; if in doubt go major

(bind-func total_key_errors
  (lambda (pcs:|12,i1|* root majmin:i1)
    (let ((res 0))
      (if majmin
          (begin ;; major
            (if (aref pcs (% (+ root 1) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 3) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 6) 12)) ;; dim 5 gets extra
                (set! res (+ res 3)))
            (if (aref pcs (% (+ root 8) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 10) 12)) ;; flat 7 - maybe not??
                (set! res (+ res 1))))
          (begin ;; minor
            (if (aref pcs (% (+ root 1) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 4) 12))
                (set! res (+ res 1)))
            (if (aref pcs (% (+ root 6) 12)) ;; dim 5 gets extra
                (set! res (+ res 3)))
            (if (aref pcs (% (+ root 9) 12))
                (set! res (+ res 1)))))
      ;; (println "root:" root "err:" res)
      (if (and (aref pcs (% (+ root 3) 12))
               (aref pcs (% (+ root 4) 12)))
          (+ res 2)
          res))))

;; where num is the num to set
;; where bit is the bit index to set
;; and where val is either 0 or 1
(bind-func bitset
  (lambda (num:i16 bit:i16 val:i16)
    (^ (& (^ -1:i16 num) (<< 1:i16 bit)) num)))

(bind-func key_analysis
  (let ((ivls:|12,i64|* (alloc))
        (pscnt 0)
        (heaviest_idx:i64 0)
        (pitchset:|12,i1|* (alloc))
        (pitchset_hist:|12,i64|* (alloc))        
        (weighted_set:|12,i64|* (alloc))
        (chord:|12,i1|* (alloc))
        (chords:|4096,i64|* (alloc))
        (previous_onset:double 0.0)
        (root 0)
        (majmin #t)
        (idx:i16 0) (i 0) (j 0)
        (pc 0))
    (lambda (note:CIMNote*)
      (set! idx 0)
      (set! pscnt 0)
      (set! heaviest_idx 0)
      ;; first record pitchset stuff
      (set! pc (% (cim_note_pitch note) 12))
      (aset! pitchset_hist pc (+ (aref pitchset_hist pc) 1))
      (aset! pitchset pc #t)
      (weighted_pcs pitchset_hist weighted_set)
      (ivls_from_pcs pitchset ivls)
      ;; next record chord stuff
      (if (< (- (cim_note_onset note) previous_onset) 0.05)
          (begin (aset! chord pc #t) void)
          (begin ;; else marks the end of the last chord
            (dotimes (i 12)
              (if (aref chord i)
                  (set! idx (bitset idx i 1))))
            (aset! chords idx (+ (aref chords idx) 1))
            void))
      (dotimes (j 12)
        (if (> (aref pitchset_hist i) heaviest_idx)
            (set! heaviest_idx j))
        (set! pscnt (+ pscnt (aref pitchset_hist j))))
      (set! previous_onset (cim_note_onset note))
      ;; (println pscnt)
      (if (> pscnt 0)
          (begin
            ;; try a simple root+majmin guess
            (set! root (best_root_match_against_pcs pitchset weighted_set))
            (set! majmin (best_majmin_guess pitchset root))))
      ;; printout
      ;; (printout pscnt " pitchset:")
      ;; (dotimes (i 12)
      ;;   (printout (aref pitchset i) ","))
      ;; (println)
      ;; (printout "pitchsethist:")
      ;; (dotimes (i 12)
      ;;   (printout (aref pitchset_hist i) ","))
      ;; (println)
      ;; (printout "weigthed:")
      ;; (dotimes (i 12)
      ;;   (printout (aref weighted_set i) ","))
      ;; (println)
      ;; printout
      ;;(println "root:" root "maj?:" majmin "errors:" (total_key_errors pitchset root majmin))      
      (if (> (aref pitchset_hist heaviest_idx) 8)
          (dotimes (j 12)
            (aset! pitchset_hist j (/ (aref pitchset_hist j) 2))))
      (if (> (total_key_errors pitchset root majmin) 0)
          (begin
            ;; (println "reset")
            (dotimes (i 12)
              (aset! pitchset i #f)
              (aset! pitchset_hist i 0))))
      void)))

(bind-func print_key_bins
  (lambda ()
    (let ((pcs:|12,i64|* (key_analysis.pitchset_hist))
          (i 0))
      (dotimes (i 12)
        (printout (aref pcs i) ","))
      (println "")
      void)))

;; negative numbers for minor
;; positive numbers for major
;; -12 for C minor
(bind-func current_key
  (lambda ()
    (let ((root:i64 (key_analysis.root))
          (majmin:i1 (key_analysis.majmin))
          (pcs:|12,i1|* (key_analysis.pitchset))
          (i 0))
      (tfill! CIM_GLOBAL_KEY root majmin)
      (if majmin
          root
          (if (= root 0) -12
              (* -1 root))))))


;; idx, time, phase, bpm, mass (total volume)
(bind-type CIMTimeSlice <i64,i64,double,double,i64,i64>)
(bind-val CIMTimeSlices |1000000,CIMTimeSlice|)
(bind-val CIMTimeSliceIdx i64 0)

(bind-func cim_tslice_idx
  (lambda (x:CIMTimeSlice*)
    (if (null? x) 0 ;; dangerous!
        (tref x 0))))

;; corresponds to EVENT onset
(bind-func cim_tslice_time
  (lambda (x:CIMTimeSlice*)
    (if (null? x) -1
        (tref x 1))))

;; corresponds to NOTE onset
(bind-func cim_tslice_onset
  (lambda (x:CIMTimeSlice*)
    (tref x 2)))

(bind-func cim_tslice_phase
  (lambda (x:CIMTimeSlice*)
    (tref x 2)))

(bind-func cim_tslice_bpm
  (lambda (x:CIMTimeSlice*)
    (if (null? x) -1
        (tref x 4))))

(bind-func cim_tslice_mass
  (lambda (x:CIMTimeSlice*)
    (tref x 5)))

(bind-func cim_tslice_mass_append
  (lambda (x:CIMTimeSlice* vol:i64)
    (tset! x 5 (+ (tref x 5) vol))))

(bind-func cim_tslice
  (lambda (idx)
    (if (or (< idx 0)
            (> idx CIMTimeSliceIdx))
        null
        (aref-ptr CIMTimeSlices idx))))

(bind-func cim_tslice_last
  (lambda ()
    (aref-ptr CIMTimeSlices CIMTimeSliceIdx)))

(bind-func cim_tslice_add_onset
  (lambda (time onset phase bpm mass)
    (let ((grp (cim_tslice CIMTimeSliceIdx))) 
      (tfill! grp CIMTimeSliceIdx time onset phase bpm mass)
      (set! CIMTimeSliceIdx (+ CIMTimeSliceIdx 1))
      grp)))

(bind-func cim_tslice_start_of_bpm
  (lambda (slice)
    (let ((bpm (cim_tslice_bpm slice))
          (idx (cim_tslice_idx slice)))
      (while (= (cim_tslice_bpm slice) bpm)
        (set! idx (- idx 1))
        (set! slice (cim_tslice idx)))
      slice)))

(bind-func cim_tslice_end_of_bpm
  (lambda (slice)
    (let ((bpm (cim_tslice_bpm slice))
          (idx (cim_tslice_idx slice)))
      (while (= (cim_tslice_bpm slice) bpm)
        (set! idx (+ idx 1))
        (set! slice (cim_tslice idx)))
      slice)))

;; search from end
;; if outside err range then return null
;;
;; both time and err in samples
(bind-func find_tslice_closest_time
  (lambda (time:i64 err)
    (let ((idx CIMTimeSliceIdx)
          (slice (cim_tslice idx))
          (slice_high null)
          (t (cim_tslice_time slice))
          (t2:i64 0))
      (while (> t time)
        (set! idx (- idx 1))
        (set! slice (cim_tslice idx))
        (set! t (cim_tslice_time slice)))
      (set! slice_high (cim_tslice (+ idx 1)))
      (set! t2 (cim_tslice_time slice_high))
      (if (< (llabs (- time t2))
             (llabs (- time t)))
          (set! slice slice_high))
      (if (< (llabs (- time (cim_tslice_time slice)))
             err)
          slice
          null))))

(bind-type CIMTimeSliceRange <CIMTimeSlice*,CIMTimeSlice*>)

;; inclusive on low end and high end
(bind-func find_tslice_range
  (let ((range (CIMTimeSliceRange null null)))
    (lambda (t1 t2)
      (let ((idx CIMTimeSliceIdx)
            (slice (cim_tslice idx))
            (slice_high null)
            (slice_low null)
            (t (cim_tslice_time slice)))
        (tfill! range null null)        
        (while (> t t2)
          (set! idx (- idx 1))
          (set! slice (cim_tslice idx))
          (set! t (cim_tslice_time slice)))
        (set! slice_high slice)
        (while (>= t t1)
          (set! idx (- idx 1))
          (set! slice (cim_tslice idx))
          (set! t (cim_tslice_time slice)))
        (set! slice_low (cim_tslice (+ idx 1)))
        (tfill! range slice_low slice_high)
        range))))

(bind-func total_tslice_beat_hits
  (lambda (start end beat)
    (let ((bpm (cim_tslice_bpm start))
          (sidx (cim_tslice_idx start))
          (eidx (cim_tslice_idx end))
          (slice null)
          (b (dtoi64 (* beat (/ 60.0 (i64tod bpm)) CIMSRd)))
          (stime (cim_tslice_time start))
          (time 0)
          (cnt 0)
          (tolerance (dtoi64 (* 200.0 (/ 60. (i64tod bpm))))) ;; in samples
          (diff 0)
          (dmod 0)
          (pos 0)
          (i 0))
      (dotimes (i (- eidx (+ sidx 1)))
        (set! slice (cim_tslice (+ 1 sidx i)))
        (set! time (cim_tslice_time slice))
        (set! diff (- time stime))
        (set! dmod (% diff b))
        (if (or (< dmod tolerance)
                (< (- dmod b) tolerance))
            (+ cnt 1)))
      cnt)))        

(bind-func record_tslice
  (let ((previous_onset 0.0)
        (this_onset 0.0)
        (bpm 0))
    (lambda (time:i64 note:CIMNote*)
      (set! bpm (current_bpm))
      (set! this_onset (cim_note_onset note))
      ;; if inter-offset less than 1/4 beat at current BPM
      ;; then just add to the mass of the current slice
      (if (< (- this_onset previous_onset) (* 0.25 (/ 60.0 (i64tod bpm))))
          (begin (cim_tslice_mass_append (cim_tslice_last)
                                         (cim_note_volume note))
                 void)
          (begin (cim_tslice_add_onset time this_onset
                                       -1.0 bpm (cim_note_volume note))
                 void))          
      (cim_tslice_last))))

;; pulse analysis

(bind-val PhaseTime i64 0)

(bind-func set_phase_time
  (lambda (t)
    (println "Adjusting Phase Time")
    (set! PhaseTime t)))

(bind-func get_phase_time
  (lambda ()
    PhaseTime))

;;  FIX ME !!!!!!!!!!!!!!!
;;  need to fix cases of err, 1/2 and 1/4 being (2 * 1) > 0
;;  i.e. need to fix cases where 1/2,1/4,err get 1 value
;;  before 1/1 even gets started!
(bind-func pulse_analysis
  (let ((bpm (dtoi64 CIM_GLOBAL_BPM))
        (err 0.0)
        (incerr 0)
        (errmax 10)
        (i 0)
        (bucket:|4,i64|* (alloc)))
    (lambda (time)
      ;; (printout "bucket: ")
      ;; (dotimes (i 4)
      ;;   (printout (aref bucket i) ","))
      ;; (println)
      (if (<> (current_bpm) bpm)
          (begin ;; (println "BPM CHANGE" (current_bpm) bpm)
            (set! bpm (current_bpm))
            (set_phase_time time)
            (dotimes (i 4) (aset! bucket i 0))))
      (set! err (% (/ (/ (i64tod (- time PhaseTime)) CIMSRd) (/ 60.0 (i64tod bpm))) 1.0))
      (cond ((or (< err 0.2)
                 (> err 0.8))
             (aset! bucket 0 (+ 1 (aref bucket 0)))
             void)
            ((and (> err 0.4)
                  (< err 0.6))
             (aset! bucket 1 (+ 1 (aref bucket 1)))
             (if (< (* 2 (aref bucket 0))
                    (aref bucket 1))
                 (begin
                   ;; (println "1/2 NOTE CHANGE")
                   (dotimes (i 4) (aset! bucket i 0))
                   (aset! bucket 0 2)
                   (if (and (> (cim_get_pedal 1) 30)
                            (> incerr errmax))
                       (begin
                         (set! incerr 0)
                         (set_phase_time time)))
                   void))
             void)
            ((or (and (> err 0.2)
                     (< err 0.3))
                (and (> err 0.7)
                     (< err 0.8)))
             (aset! bucket 2 (+ 1 (aref bucket 2)))
             (if (< (* 3 (aref bucket 0))
                    (aref bucket 2))
                 (begin
                   ;; (println "1/4 NOTE CHANGE")
                   (dotimes (i 4) (aset! bucket i 0))
                   (aset! bucket 0 2)
                   (if (and (> (cim_get_pedal 1) 30)
                            (> incerr errmax))                               
                       (begin
                         (set! incerr 0)
                         (set_phase_time time)))
                   void))
             void)
            (else
             (aset! bucket 3 (+ 1 (aref bucket 3)))
             (if (< (* 2 (aref bucket 0))
                    (aref bucket 3))
                 (begin (dotimes (i 4) (aset! bucket i 0))
                        ;; (println "ERR CHANGE")
                        (aset! bucket 0 1)
                        (if (and (> (cim_get_pedal 1) 30)
                                 (> incerr errmax))
                            (begin
                              (set! incerr 0)
                              (set_phase_time time)))
                        void))
             void))
      ;; might not need this but ...
      (if (= (aref bucket 0) 8)
          (begin (dotimes (i 4)
                   (aset! bucket i (/ (aref bucket i) 2)))
                 (aset! bucket 0 4)))
      void)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Basic density analysis
;;

(bind-func density_analysis
  (let ((times:|80,i64|* (alloc))
        (pos:i64 0)
        (cnt 1) (i 0)
        (history 0)
        (lasttime 0)
        (density:double 0.5))
    (lambda (time:i64 time_window:i64)
      (set! lasttime time)
      (aset! times pos time)
      (set! history (- time time_window))
      (set! cnt 0)
      (dotimes (i 80)
        (if (> (aref times i) history)
            (set! cnt (+ cnt 1))))
      (set! density (/ (i64tod cnt) 80.0))
      (set! pos (+ pos 1))
      (if (= pos 80) (set! pos 0))
      void)))

(bind-func current_density
  (lambda ()
    (let ((val:double (density_analysis.density))
          (t:i64 (density_analysis.lasttime)))
      (if (> (- (now) t) CIMSR)
          0.0
          val))))

;; 
;; basic velocity analysis
;;
(bind-func velocity_analysis
  (let ((velocities:|30,i64|* (alloc))
        (times:|30,i64|* (alloc))
        (num 0) (avg 0) (avg2 0) (idx 0))
    (lambda (time:i64 time_window:i64 note:CIMNote*)
      (aset! velocities idx (cim_note_volume note))
      (aset! times idx time)
      (set! avg2 0) (set! num 0)
      (dotimes (i 30)
        (if (< (- time (aref times i)) time_window)
            (begin
              (set! num (+ num 1))
              (set! avg2 (+ avg2 (aref velocities i))))))
      (set! avg (/ avg2 num))
      (set! idx (+ idx 1))
      (if (>= idx 30)
          (set! idx 0))
      void)))

(bind-func current_avg_veclocity
  (lambda ()
    (velocity_analysis.avg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Currently active notes and PCS
;;

(bind-func current_pcs
  (let ((cnt 0) (i 0)
        (pcs:i64* (alloc 12)))
    (lambda ()
      (dotimes (i 12) (pset! pcs i 0))
      (dotimes (i 127)
        (if (> (aref CIMNoteDurResolver i) -1)
            (pset! pcs (% i 12) 1)))
      pcs)))

(bind-func current_pitch_range_low
  (let ((low 0) (i 0))
    (lambda ()
      (set! low 127)
      (dotimes (i 127)
        (if (and (>  (aref CIMNoteDurResolver i) -1)
                 (< i low))
            (set! low i)))
      low)))

(bind-func current_pitch_range_high
  (let ((high 127) (i 0))
    (lambda ()
      (set! high 0)
      (dotimes (i 127)
        (if (and (> (aref CIMNoteDurResolver i) -1)
                 (> i high))
            (set! high i)))
      high)))

(bind-func current_polyphony_cnt
  (let ((cnt 0) (i 0))
    (lambda ()
      (set! cnt 0)
      (dotimes (i 127)
        (if (> (aref CIMNoteDurResolver i) -1)
            (set! cnt (+ cnt 1))))
      cnt)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Analysis
;;
(bind-func analysis
  (lambda (time:i64 note:CIMNote*)
    (if (null? note) void
        (begin          
          ;;(println "analysis: >>" note)          
          (bpm_analysis note)
          (pulse_analysis time)
          (key_analysis note)
          (density_analysis time (dtoi64 (* 2.0 CIMSRd)))
          (velocity_analysis time (dtoi64 ( 2.0 CIMSRd)) note)
          void))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; write a midi receiver which writes to MSG Buffer and Note Buffer
;;

(bind-val CIM_LOAD_TIME double 0.0)
(bind-val CIM_PRINT_MIDI_MESSAGES i1 0)

(bind-func cim_print_midi_messages
  (lambda (x)
    (set! CIM_PRINT_MIDI_MESSAGES x)))

(bind-func set_lib_load_time
  (lambda ()
    (set! CIM_LOAD_TIME (clock_clock))))

(set_lib_load_time)

(bind-func midi_msg_buffer_receiver
  (let ((type:i8 0) (chan:i8 0) (a:i8 0) (b:i8 0) (idx -1)
        (note:CIMNote* null)
        (time_of_first_message 0.0))
    (lambda (time:double len:i64 msg:i8*)
      (set! type (>> (pref msg 0) 4))
      (set! chan (& (pref msg 0) 15))
      (set! a (pref msg 1))
      (set! b (pref msg 2))
      (if (or (= type MIDI_NOTE_ON) (= type MIDI_NOTE_OFF) (= type MIDI_CC))
          (let ((t1 (now))
                (t2 (dtoi64 (* CIMSRd (- (clock_clock) (audio_clock_base)))))
                (t t2))
            (if CIM_PRINT_MIDI_MESSAGES (println "midi-in" type chan a b))
            (record_midi_msg t type (convert chan) (convert a) (convert b))
            (if (or (= type MIDI_NOTE_ON) (= type MIDI_NOTE_OFF))
                (if (<> chan 1:i8)
                    (begin
                      (set! idx (record_note t type (convert chan) (convert a) (convert b)))
                      (set! note (retrieve_note idx))
                      (if (> (cim_get_pedal 1) 30) (analysis t note))
                      (if (and (> idx -1) (= (cim_get_pedal 2) 0))
                          (begin
                            (set! CIMNoteBufferIdx (- CIMNoteBufferIdx 1))))
                      void)
                    (begin
                      (cond ((= a 4:i8) (cim_set_pedal 1 (i8toi64 b)) void)
                            ((= a 5:i8) (cim_set_pedal 2 (i8toi64 b)) void)
                            ((= a 3:i8) (cim_set_pedal 4 (i8toi64 b)) void)
                            ((= a 2:i8) (cim_set_pedal 5 (i8toi64 b)) void)            
                            (else void))
                      void)))
            (if (= type MIDI_CC)
                (cond ((= a 64:i8)
                       (if (= (cim_get_pedal 2) 30)
                           (record_note t type (convert chan) (convert a) (convert b)))
                       void)
                      ((= a 66:i8)
                       (cim_set_pedal 4 (i8toi64 b))
                       void)
                      ((= a 67:i8)
                       (cim_set_pedal 5 (i8toi64 b))
                       void)
                      ((= a 68:i8)
                       (cim_set_pedal 1 (i8toi64 b))
                       void)
                      ((= a 69:i8)
                       (cim_set_pedal 2 (i8toi64 b))
                       void)
                      ((= a 10:i8) ;; 10 and 21 the same
                       (cim_set_pedal 3 (i8toi64 b))
                       void)
                      ((= a 7:i8) ;; 10 and 21 the same
                       (cim_set_pedal 3 (i8toi64 b))
                       void)
                      ((= a 21:i8) ;; 10 and 21 the same
                       (cim_set_pedal 3 (i8toi64 b))
                       void)
                      (else ;; nothing,
                       void)))
            ;;(record_tslice t note)
            void)
          void))))

(sys:precomp:insert-footer "xtmcimlib")
(define *xtmlib-cimlib-loaded* #t)
